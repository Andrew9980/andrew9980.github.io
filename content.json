{"meta":{"title":"安德鲁的时光机","subtitle":"不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之","description":"","author":"Andrew","url":"http://andrew9980.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-01-05T07:17:33.876Z","updated":"2022-01-05T07:17:33.876Z","comments":false,"path":"/404.html","permalink":"http://andrew9980.github.io/404.html","excerpt":"","text":""},{"title":"分类","date":"2022-01-05T08:26:30.372Z","updated":"2022-01-05T08:26:30.372Z","comments":false,"path":"categories/index.html","permalink":"http://andrew9980.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-01-05T07:17:33.880Z","updated":"2022-01-05T07:17:33.880Z","comments":false,"path":"about/index.html","permalink":"http://andrew9980.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2022-01-05T07:17:33.881Z","updated":"2022-01-05T07:17:33.881Z","comments":false,"path":"books/index.html","permalink":"http://andrew9980.github.io/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-01-05T07:17:33.884Z","updated":"2022-01-05T07:17:33.884Z","comments":false,"path":"repository/index.html","permalink":"http://andrew9980.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-01-05T08:14:53.711Z","updated":"2022-01-05T08:14:53.711Z","comments":true,"path":"links/index.html","permalink":"http://andrew9980.github.io/links/index.html","excerpt":"","text":"友情链接"},{"title":"标签","date":"2022-01-05T08:27:21.829Z","updated":"2022-01-05T07:17:33.885Z","comments":false,"path":"tags/index.html","permalink":"http://andrew9980.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"线上RocketMQ发送消息system busy问题分析","slug":"线上RocketMQ发送消息system-busy问题分析","date":"2022-01-30T06:48:19.000Z","updated":"2022-01-30T08:49:41.432Z","comments":true,"path":"2022/01/30/线上RocketMQ发送消息system-busy问题分析/","link":"","permalink":"http://andrew9980.github.io/2022/01/30/%E7%BA%BF%E4%B8%8ARocketMQ%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AFsystem-busy%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/","excerpt":"","text":"问题最近项目的RocketMQ监控有些消息发送失败了，于是上服务器上查看日志： 可以看到发送消息失败，报出了system busy, start flow control for a while的错误信息 分析接下来，我们根据报错信息进入rocketmq源码分析，我的rocketmq源码环境是4.9.3 123&lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;&lt;artifactId&gt;rocketmq-all&lt;/artifactId&gt;&lt;version&gt;4.9.3-SNAPSHOT&lt;/version&gt; 通过system busy关键字在源码中查找，可以发现主要在NettyRemotingAbstract这个类中，存在两种情况 [REJECTREQUEST]system busy, start flow control for a while [OVERLOAD]system busy, start flow control for a while 首先分析第一种： REJECTREQUEST12final Pair&lt;NettyRequestProcessor, ExecutorService&gt; matched = this.processorTable.get(cmd.getCode()); final Pair&lt;NettyRequestProcessor, ExecutorService&gt; pair = null == matched ? this.defaultRequestProcessor : matched; cmd.getCode()：主要是对应RequestCode，表示客户端请求的类型，通过RequestCode这个类进行枚举，其中SEND_MESSAGE = 10（表示发送消息），Pull Message =11 (表示拉取消息)，详细请自行阅读源码。 1234567if (pair.getObject1().rejectRequest()) &#123; final RemotingCommand response = RemotingCommand.createResponseCommand(RemotingSysResponseCode.SYSTEM_BUSY, &quot;[REJECTREQUEST]system busy, start flow control for a while&quot;); response.setOpaque(opaque); ctx.writeAndFlush(response); return;&#125; 可以看到错误抛出是因为pair.getObject1().rejectRequest()==true，我们分析一下pair的object1的NettyRequestProcessor作用。 NettyRequestProcessorNettyRequestProcessor是rocketmq服务端请求的处理器接口，定义了两个方法，处理请求和拒绝请求 12345public interface NettyRequestProcessor &#123; RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request) throws Exception; boolean rejectRequest();&#125; 我们看看有哪些实现类： 可以看到，rocketmq对于不同的请求实现了很多场景的处理器，我们这里是发消息失败了，则主要是调用的SendMessageProcessor来处理发送消息的。而PullMessageProcessor是处理拉取消息的处理器。 PairPair主要是将每个处理绑定一个固定的线程池来处理请求，发送消息报错了则是直接调用的SendMessageProcessor#rejectRequest() 12345@Overridepublic boolean rejectRequest() &#123; return this.brokerController.getMessageStore().isOSPageCacheBusy() || this.brokerController.getMessageStore().isTransientStorePoolDeficient();&#125; 这里判断硬盘的page cache是否繁忙，在消息存储时，会首先写到硬盘的page cache，为了保证消息追加时的线程安全，会获取写锁，如果写锁的持有时间过长，则isOSPageCacheBusy==true。或者TransientStorePool容量不足时也会报错。TransientStorePool通过transientStorePoolEnable=true配置开启，此时会将消息写到堆外。 所以我们可以总结一下消息写入的流程： 客户端发送消息给rocketmq服务器 服务器接收到请求后，通过Request Code从全局的处理器配置表中找到SendMessageProcessor来进行处理 接着判断请求是否能执行，主要检查page cache是否翻盘（通过获取写锁的超时时间） 如果写锁获取失败或者堆外内存满了（需要开启配置）则会拒绝执行请求，否则进行处理发送请求业务 从中我们可以得到一个处理锁时间过长的问题的方案，可以通过配置transientStorePoolEnable=true, 将消息内容写入到堆外，而读消息直接从page cache中读取。然后通过异步的方式将堆外的数据刷到page cache中，从而实现读写分离，降低并发压力。不过此方案的缺点是当rocketmq服务宕机了，堆外存储的消息就会丢失了。此方案根据业务来选择。 至此，[REJECTREQUEST]system busy, start flow control for a while 问题分析完毕。接下来分析第二种： OVERLOAD从第一种问题可以看出，如果rejectRequest返回false，则代表page cache不繁忙，堆外空间也足够（配置开启时）。则会调用发送消息处理器，提交任务到绑定的线程池中执行任务。 123456789101112131415161718try &#123; final RequestTask requestTask = new RequestTask(run, ctx.channel(), cmd); pair.getObject2().submit(requestTask);&#125; catch (RejectedExecutionException e) &#123; if ((System.currentTimeMillis() % 10000) == 0) &#123; log.warn(RemotingHelper.parseChannelRemoteAddr(ctx.channel()) + &quot;, too many requests and system thread pool busy, RejectedExecutionException &quot; + pair.getObject2().toString() + &quot; request code: &quot; + cmd.getCode()); &#125; if (!cmd.isOnewayRPC()) &#123; final RemotingCommand response = RemotingCommand.createResponseCommand(RemotingSysResponseCode.SYSTEM_BUSY, &quot;[OVERLOAD]system busy, start flow control for a while&quot;); response.setOpaque(opaque); ctx.writeAndFlush(response); &#125;&#125; 我们进入处理发送消息处理器SendMessageProcessor类中，从构造方法中可以看到传入了一个BrokerController参数。从BrokerController中我们可以看出处理器的线程池配置信息，在BrokerController的构造方法中配置了各种处理器线程池的队列，我们找到了sendThreadPoolQueue 1234567891011121314public BrokerController( final BrokerConfig brokerConfig, final NettyServerConfig nettyServerConfig, final NettyClientConfig nettyClientConfig, final MessageStoreConfig messageStoreConfig ) &#123; // 省略 this.sendThreadPoolQueue = new LinkedBlockingQueue&lt;Runnable&gt;(this.brokerConfig.getSendThreadPoolQueueCapacity()); this.pullThreadPoolQueue = new LinkedBlockingQueue&lt;Runnable&gt;(this.brokerConfig.getPullThreadPoolQueueCapacity()); this.replyThreadPoolQueue = new LinkedBlockingQueue&lt;Runnable&gt;(this.brokerConfig.getReplyThreadPoolQueueCapacity()); this.queryThreadPoolQueue = new LinkedBlockingQueue&lt;Runnable&gt;(this.brokerConfig.getQueryThreadPoolQueueCapacity()); // 省略。。 &#125; 队列大小从brokerConfig中获取，我们进去看看： 1234567891011121314151617public class BrokerConfig &#123; // 省略。。 private int sendThreadPoolQueueCapacity = 10000; private int pullThreadPoolQueueCapacity = 100000; private int replyThreadPoolQueueCapacity = 10000; private int queryThreadPoolQueueCapacity = 20000; private int clientManagerThreadPoolQueueCapacity = 1000000; private int consumerManagerThreadPoolQueueCapacity = 1000000; private int heartbeatThreadPoolQueueCapacity = 50000; private int endTransactionPoolQueueCapacity = 100000; // 省略。。 public void setSendThreadPoolQueueCapacity(int sendThreadPoolQueueCapacity) &#123; this.sendThreadPoolQueueCapacity = sendThreadPoolQueueCapacity; &#125; public int getSendThreadPoolQueueCapacity() &#123; return sendThreadPoolQueueCapacity; &#125; 由此得知，线程池的队列大小默认是10000，然后通过broker配置来调整大小。在BrokerController中我们在initialize方法中找到了线程池初始化的代码： 1234567891011121314151617 public boolean initialize() throws CloneNotSupportedException &#123;// 省略。。 if (result) &#123; this.remotingServer = new NettyRemotingServer(this.nettyServerConfig, this.clientHousekeepingService); NettyServerConfig fastConfig = (NettyServerConfig) this.nettyServerConfig.clone(); fastConfig.setListenPort(nettyServerConfig.getListenPort() - 2); this.fastRemotingServer = new NettyRemotingServer(fastConfig, this.clientHousekeepingService); this.sendMessageExecutor = new BrokerFixedThreadPoolExecutor( this.brokerConfig.getSendMessageThreadPoolNums(), this.brokerConfig.getSendMessageThreadPoolNums(), 1000 * 60, TimeUnit.MILLISECONDS, this.sendThreadPoolQueue, new ThreadFactoryImpl(&quot;SendMessageThread_&quot;)); &#125; // 省略。。 &#125; 1234567public class BrokerFixedThreadPoolExecutor extends ThreadPoolExecutor &#123; public BrokerFixedThreadPoolExecutor(final int corePoolSize, final int maximumPoolSize, final long keepAliveTime, final TimeUnit unit, final BlockingQueue&lt;Runnable&gt; workQueue, final ThreadFactory threadFactory) &#123; super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory); &#125;&#125; 在broker启动的时候，会实例化BrokerController，并调用initialize方法（源码在BrokerStartup类中，详细内容请自行阅读源码），此时会构造出发送消息处理器的线程池，线程池的队列使用的是LinkedBlockingQueue，容量获取上文分析过，core，max也可以在BrokerConfig中找到配置。因为BrokerFixedThreadPoolExecutor没有定义队列的拒绝策略，则会走默认的拒绝策略AbortPolicy（任务拒绝执行，并抛出RejectedExecutionException异常）。 由此，当线程池队列满时，抛出RejectedExecutionException，被catch后，执行错误逻辑 1[OVERLOAD]system busy, start flow control for a while 不过，执行这个错误主要走了oneway判断，oneway表示客户端只负责发送消息，不用等待服务器的回调，类似kafka的ack=0的场景。因为客户端配置不是oneway，则会收到这个错误回应。 总结两种system busy主要是对应两种情况 获取page cache写锁超时 处理器对应的线程池队列满了 对于第一种，可以通过配置transientStorePoolEnable=true，来开启堆外内存，消息方法时会先写入DirectByteBuffer（堆外内存），后面通过异步刷盘方式提交到page cache中，拉取消息时，再从page cache中拉取，实现了读写分离，降低了page cache压力，不过缺点是broker宕机后，堆外还没来得及刷盘的数据会出现丢失。 对于第二种，线程池队列满了，说明请求过多，可以对broker进行扩容，增加topic的队列数，降低单台Broker服务器的负载，从而降低了线程池队列的负载。","categories":[{"name":"RocketMQ","slug":"RocketMQ","permalink":"http://andrew9980.github.io/categories/RocketMQ/"}],"tags":[{"name":"线上问题","slug":"线上问题","permalink":"http://andrew9980.github.io/tags/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"RocketMQ","slug":"RocketMQ","permalink":"http://andrew9980.github.io/tags/RocketMQ/"}]},{"title":"4-Spring源码解析-Bean实例化流程","slug":"4-Spring源码解析-Bean实例化流程","date":"2022-01-05T09:27:52.000Z","updated":"2022-01-07T12:05:29.912Z","comments":true,"path":"2022/01/05/4-Spring源码解析-Bean实例化流程/","link":"","permalink":"http://andrew9980.github.io/2022/01/05/4-Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%B5%81%E7%A8%8B/","excerpt":"","text":"回顾一下前面的代码，我们分析了Spring是如何解析xml及注册BeanDefinition到BeanFactory，接下来我们从分析Spring如何获取bean的流程。贴一下前面的代码。 12345678public static void main(String[] args) throws IOException &#123; DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); XmlBeanDefinitionReader definitionReader = new XmlBeanDefinitionReader(beanFactory); ClassPathResource resource = new ClassPathResource(&quot;application.xml&quot;); definitionReader.loadBeanDefinitions(resource); Object user = beanFactory.getBean(&quot;user&quot;); System.out.println(user.toString());&#125; Bean实例化我们进入DefaultListableBeanFactory#getBean方法看看。 123public Object getBean(String name) throws BeansException &#123; return doGetBean(name, null, null, false);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167protected &lt;T&gt; T doGetBean( String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException &#123; // 转换factoryBean的name或者aliasName成为真正beanName String beanName = transformedBeanName(name); Object beanInstance; // 检查手动创建的单例缓存 Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) &#123; if (logger.isTraceEnabled()) &#123; if (isSingletonCurrentlyInCreation(beanName)) &#123; logger.trace(&quot;Returning eagerly cached instance of singleton bean &#x27;&quot; + beanName + &quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;); &#125; else &#123; logger.trace(&quot;Returning cached instance of singleton bean &#x27;&quot; + beanName + &quot;&#x27;&quot;); &#125; &#125; // 有可能getSingleton()获取的bean是最原始的bean，此方法则获取最终的bean实例 beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; // 如果当前bean不是singleton并且正在创建则报错 // 只能处理单例bean的循环依赖问题 if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; // Check if bean definition exists in this factory. // 检查是否有父BeanFactory BeanFactory parentBeanFactory = getParentBeanFactory(); // 如果父BeanFactory存在并且beanDefinitionMap不存在 if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; // Not found -&gt; check parent. // 获取原始beanName String nameToLookup = originalBeanName(name); // 如果父BeanFactory是AbstractBeanFactory则委托AbstractBeanFactory创建对象 if (parentBeanFactory instanceof AbstractBeanFactory) &#123; return ((AbstractBeanFactory) parentBeanFactory).doGetBean( nameToLookup, requiredType, args, typeCheckOnly); &#125; else if (args != null) &#123; // 委托有参构造 return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else if (requiredType != null) &#123; // No args -&gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; else &#123; // return (T) parentBeanFactory.getBean(nameToLookup); &#125; &#125; if (!typeCheckOnly) &#123; markBeanAsCreated(beanName); &#125; StartupStep beanCreation = this.applicationStartup.start(&quot;spring.beans.instantiate&quot;) .tag(&quot;beanName&quot;, name); try &#123; if (requiredType != null) &#123; beanCreation.tag(&quot;beanType&quot;, requiredType::toString); &#125; // 从容器中获取GenericBeanDefinition，并转换为RootBeanDefinition RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // Guarantee initialization of beans that the current bean depends on. // 处理当前bean的依赖bean，主要是针对dependsOn属性解决循环依赖 String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) &#123; for (String dep : dependsOn) &#123; if (isDependent(beanName, dep)) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Circular depends-on relationship between &#x27;&quot; + beanName + &quot;&#x27; and &#x27;&quot; + dep + &quot;&#x27;&quot;); &#125; // 注册依赖的bean registerDependentBean(dep, beanName); try &#123; // 实例化依赖的bean getBean(dep); &#125; catch (NoSuchBeanDefinitionException ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;&#x27;&quot; + beanName + &quot;&#x27; depends on missing bean &#x27;&quot; + dep + &quot;&#x27;&quot;, ex); &#125; &#125; &#125; // Create bean instance. 实例化依赖的bean后，创建指定name的bean实例 if (mbd.isSingleton()) &#123; // 调用getSingleton方法，先查询singletonObjects缓存中的对象，如果没有查到则调用createBean方法 sharedInstance = getSingleton(beanName, () -&gt; &#123; try &#123; return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. // 为了解决循环依赖问题，可能已经被实例化了，所以报错，在这里删除bean destroySingleton(beanName); throw ex; &#125; &#125;); // 处理bean是否是FactoryBean情况 beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; else if (mbd.isPrototype()) &#123; // It&#x27;s a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; // 前置处理 beforePrototypeCreation(beanName); // 创建bean prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; // 后置处理 afterPrototypeCreation(beanName); &#125; // 从bean实例中获取对象 beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125; else &#123; String scopeName = mbd.getScope(); if (!StringUtils.hasLength(scopeName)) &#123; throw new IllegalStateException(&quot;No scope name defined for bean ´&quot; + beanName + &quot;&#x27;&quot;); &#125; Scope scope = this.scopes.get(scopeName); if (scope == null) &#123; throw new IllegalStateException(&quot;No Scope registered for scope name &#x27;&quot; + scopeName + &quot;&#x27;&quot;); &#125; try &#123; Object scopedInstance = scope.get(beanName, () -&gt; &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125;); beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; catch (IllegalStateException ex) &#123; throw new ScopeNotActiveException(beanName, scopeName, ex); &#125; &#125; &#125; catch (BeansException ex) &#123; beanCreation.tag(&quot;exception&quot;, ex.getClass().toString()); beanCreation.tag(&quot;message&quot;, String.valueOf(ex.getMessage())); cleanupAfterBeanCreationFailure(beanName); throw ex; &#125; finally &#123; beanCreation.end(); &#125; &#125; return adaptBeanInstance(name, beanInstance, requiredType);&#125; 先调用transformedBeanName方法，将beanName转化一下，主要是去掉&amp;（factoryName）或者基于alias找到匹配的beanName。然后调用getSingleton从缓存中查，逻辑如下。 123456789101112131415161718192021222324252627282930313233343536public Object getSingleton(String beanName) &#123; return getSingleton(beanName, true);&#125;protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123; // Quick check for existing instance without full singleton lock // 从已经实例化过的单例bean缓存中查询（一级缓存） Object singletonObject = this.singletonObjects.get(beanName); // 如果一级缓存查不到则判断 bean 是否被正在创建 if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123; // 从二级缓存查找 singletonObject = this.earlySingletonObjects.get(beanName); // 如果二级缓存查不到并且允许提前创建 if (singletonObject == null &amp;&amp; allowEarlyReference) &#123; synchronized (this.singletonObjects) &#123; // Consistent creation of early reference within full singleton lock // 再次从一级/二级缓存获取 singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) &#123; singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null) &#123; // 从objectFactory中获取，如果存在objectFactory则直接获取对象 ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) &#123; singletonObject = singletonFactory.getObject(); // 从三级缓存中拿到对象后放入二级缓存 this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); &#125; &#125; &#125; &#125; &#125; &#125; return singletonObject;&#125; 具体的逻辑注释中已经写明了，下面说一下一级，二级，三级缓存是什么。 Map&lt;String, Object&gt; singletonObjects：一级缓存，主要存储已经实例化的Bean对象 Map&lt;String, Object&gt; earlySingletonObjects：二级缓存，主要存储提前暴露的Bean对象 Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories：三级缓存，主要存储用户创建对象的ObjectFactory 我们继续往下走，当从缓存中都拿不到对象时，判断当前beanName是否是单例，并且正在被创建，如果是则报错，否则获取是否有parentBeanFactory，如果没有则标记当前beanName标记为正在被创建。 123456789101112protected void markBeanAsCreated(String beanName) &#123; if (!this.alreadyCreated.contains(beanName)) &#123; synchronized (this.mergedBeanDefinitions) &#123; if (!this.alreadyCreated.contains(beanName)) &#123; // Let the bean definition get re-merged now that we&#x27;re actually creating // the bean... just in case some of its metadata changed in the meantime. clearMergedBeanDefinition(beanName); this.alreadyCreated.add(beanName); &#125; &#125; &#125;&#125; 然后调用getMergedLocalBeanDefinition获取MergedBeanDefinition。 MergedBeanDefinition 本质上是一个RootBeanDefinition，主要是原始的BeanDefinition和双亲BeanDefinition的定义信息合并而来的RootBeanDefinition。在Bean属性注入之前，可以通过实现MergedBeanDefinitionPostProcessor接口来对生成的MergedBeanDefinition进行回调。 我们进入方法看看具体逻辑： 123456789protected RootBeanDefinition getMergedLocalBeanDefinition(String beanName) throws BeansException &#123; // Quick check on the concurrent map first, with minimal locking. RootBeanDefinition mbd = this.mergedBeanDefinitions.get(beanName); // 判断已经合并的beanDefinition并且不需要再合并则直接返回 if (mbd != null &amp;&amp; !mbd.stale) &#123; return mbd; &#125; return getMergedBeanDefinition(beanName, getBeanDefinition(beanName));&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586protected RootBeanDefinition getMergedBeanDefinition( String beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd) throws BeanDefinitionStoreException &#123; synchronized (this.mergedBeanDefinitions) &#123; RootBeanDefinition mbd = null; RootBeanDefinition previous = null; // Check with full lock now in order to enforce the same merged instance. // 如果是顶层bean直接从mergedBeanDefinitions获取返回 if (containingBd == null) &#123; mbd = this.mergedBeanDefinitions.get(beanName); &#125; // 如果获取不到，或者需要再次合并 if (mbd == null || mbd.stale) &#123; previous = mbd; // 如果当前bean的父类为null则代表 // 当前bean是一个独立的GenericBeanDefinition或者是一个RootBeanDefinition if (bd.getParentName() == null) &#123; // Use copy of given root bean definition. if (bd instanceof RootBeanDefinition) &#123; // 如果是RootBeanDefinition则复制一个 mbd = ((RootBeanDefinition) bd).cloneBeanDefinition(); &#125; else &#123; // 如果是GenericBeanDefinition，则通过RootBeanDefinition再包装一层 mbd = new RootBeanDefinition(bd); &#125; &#125; else &#123; // Child bean definition: needs to be merged with parent. BeanDefinition pbd; try &#123; String parentBeanName = transformedBeanName(bd.getParentName()); // 这里判断如果当前bean还有父类则使用递归调用 if (!beanName.equals(parentBeanName)) &#123; pbd = getMergedBeanDefinition(parentBeanName); &#125; else &#123; BeanFactory parent = getParentBeanFactory(); if (parent instanceof ConfigurableBeanFactory) &#123; pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName); &#125; else &#123; throw new NoSuchBeanDefinitionException(parentBeanName, &quot;Parent name &#x27;&quot; + parentBeanName + &quot;&#x27; is equal to bean name &#x27;&quot; + beanName + &quot;&#x27;: cannot be resolved without a ConfigurableBeanFactory parent&quot;); &#125; &#125; &#125; catch (NoSuchBeanDefinitionException ex) &#123; throw new BeanDefinitionStoreException(bd.getResourceDescription(), beanName, &quot;Could not resolve parent bean definition &#x27;&quot; + bd.getParentName() + &quot;&#x27;&quot;, ex); &#125; // Deep copy with overridden values. // 最后将父类bean包装成RootBeanDefinition，合并成所有父类的merged beandefinition // 然后将mbd和当前的db合并形成最终的mdb mbd = new RootBeanDefinition(pbd); mbd.overrideFrom(bd); &#125; // Set default singleton scope, if not configured before. if (!StringUtils.hasLength(mbd.getScope())) &#123; mbd.setScope(SCOPE_SINGLETON); &#125; // A bean contained in a non-singleton bean cannot be a singleton itself. // Let&#x27;s correct this on the fly here, since this might be the result of // parent-child merging for the outer bean, in which case the original inner bean // definition will not have inherited the merged outer bean&#x27;s singleton status. if (containingBd != null &amp;&amp; !containingBd.isSingleton() &amp;&amp; mbd.isSingleton()) &#123; mbd.setScope(containingBd.getScope()); &#125; // Cache the merged bean definition for the time being // (it might still get re-merged later on in order to pick up metadata changes) if (containingBd == null &amp;&amp; isCacheBeanMetadata()) &#123; this.mergedBeanDefinitions.put(beanName, mbd); &#125; &#125; if (previous != null) &#123; copyRelevantMergedBeanDefinitionCaches(previous, mbd); &#125; return mbd; &#125;&#125; 主要就是将当前的bean和其所有的父类bean信息进行合并，得到一个包含有本身信息及其双亲bean信息的RootBeanDefinition。 接下来是判断bean是否有dependsOn的bean，如果有则提前注册并实例化，主要是解决循环依赖问题。 下面主要分析bean的实例化逻辑，getSingleton方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123; Assert.notNull(beanName, &quot;Bean name must not be null&quot;); synchronized (this.singletonObjects) &#123; // 查询已经注册了的bean Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) &#123; if (this.singletonsCurrentlyInDestruction) &#123; throw new BeanCreationNotAllowedException(beanName, &quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot; + &quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;); &#125; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Creating shared instance of singleton bean &#x27;&quot; + beanName + &quot;&#x27;&quot;); &#125; // 创建bean的前置处理 beforeSingletonCreation(beanName); boolean newSingleton = false; // 创建新bean标志 boolean recordSuppressedExceptions = (this.suppressedExceptions == null); if (recordSuppressedExceptions) &#123; this.suppressedExceptions = new LinkedHashSet&lt;&gt;(); &#125; try &#123; singletonObject = singletonFactory.getObject(); // 调用创建方法createBean newSingleton = true; &#125; catch (IllegalStateException ex) &#123; // Has the singleton object implicitly appeared in the meantime -&gt; // if yes, proceed with it since the exception indicates that state. singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) &#123; throw ex; &#125; &#125; catch (BeanCreationException ex) &#123; if (recordSuppressedExceptions) &#123; for (Exception suppressedException : this.suppressedExceptions) &#123; ex.addRelatedCause(suppressedException); &#125; &#125; throw ex; &#125; finally &#123; if (recordSuppressedExceptions) &#123; this.suppressedExceptions = null; &#125; // 创建bean后置调用 afterSingletonCreation(beanName); &#125; // 如果创建新bean，则将新bean注册到singletonObjects中 if (newSingleton) &#123; addSingleton(beanName, singletonObject); &#125; &#125; return singletonObject; &#125; &#125; 首先从一级缓存中查找，如果有则直接返回，如果没有则调用ObjectFactory的getObject方法，此时会触发createBean()进行bean的真正创建。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Creating instance of bean &#x27;&quot; + beanName + &quot;&#x27;&quot;); &#125; RootBeanDefinition mbdToUse = mbd; // Make sure bean class is actually resolved at this point, and // clone the bean definition in case of a dynamically resolved Class // which cannot be stored in the shared merged bean definition. // 解析出BeanDefinition的Class Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName); if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123; mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); &#125; // Prepare method overrides. try &#123; mbdToUse.prepareMethodOverrides(); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, &quot;Validation of method overrides failed&quot;, ex); &#125; try &#123; // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) &#123; return bean; &#125; &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex); &#125; try &#123; // 真正做创建bean的方法 Object beanInstance = doCreateBean(beanName, mbdToUse, args); if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Finished creating instance of bean &#x27;&quot; + beanName + &quot;&#x27;&quot;); &#125; return beanInstance; &#125; // 省略不必要代码... &#125; 首先从RootBeanDefinition中解析出bean的class类便于后面通过反射实例化。然后执行bean实例化的前置调用，主要是对应于实现了InstantiationAwareBeanPostProcessor接口的bean。 我们进入doCreateBean()方法，再进入createBeanInstance方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) &#123; // Make sure bean class is actually resolved at this point. // 确保BeanDefinition的Class正确，class可以访问 Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName); if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot; + beanClass.getName()); &#125; // Supplier创建对象 Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier(); if (instanceSupplier != null) &#123; return obtainFromSupplier(instanceSupplier, beanName); &#125; // 使用工厂方法实例化 if (mbd.getFactoryMethodName() != null) &#123; return instantiateUsingFactoryMethod(beanName, mbd, args); &#125; // Shortcut when re-creating the same bean... // 如果是对于相同beanName的bean实例化可以缓存其构造器参数避免构造器判断从而快速创建 boolean resolved = false; // 表示有没有必要要进行注入，比如当前BeanDefinition用的是无参构造方法，那么为false，否则需要给构造方法参数注入值 boolean autowireNecessary = false; if (args == null) &#123; // 只有当无参数时才能使用缓存的构造器 synchronized (mbd.constructorArgumentLock) &#123; if (mbd.resolvedConstructorOrFactoryMethod != null) &#123; resolved = true; autowireNecessary = mbd.constructorArgumentsResolved; &#125; &#125; &#125; if (resolved) &#123; if (autowireNecessary) &#123; // 使用有参构造器实例化 return autowireConstructor(beanName, mbd, null, null); &#125; else &#123; // 使用无参构造器实例化 return instantiateBean(beanName, mbd); &#125; &#125; // Candidate constructors for autowiring? // 当没有命中到缓存的构造器，那就需要开始找了 // 这里可以利用SmartInstantiationAwareBeanPostProcessor来控制用beanClass中的哪些构造方法，比如AutowiredAnnotationBeanPostProcessor会把加了@Autowired注解的构造方法找出来 Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123; // 如果构造器找到了，并且参数都实例化完成则使用有参构造器 return autowireConstructor(beanName, mbd, ctors, args); &#125; // Preferred constructors for default construction? ctors = mbd.getPreferredConstructors(); if (ctors != null) &#123; // 最后使用默认的构造方法 return autowireConstructor(beanName, mbd, ctors, null); &#125; // No special handling: simply use no-arg constructor. 使用简单无参构造器实例化 return instantiateBean(beanName, mbd); &#125; 首先对bean的class进行校验后判断使用哪种实例化: Supplier（通过beanDefinition.setInstanceSupplier(() -&gt; new User())设置）， 工厂方法 构造器（有参和无参） 其中还判断了是否可以快速实例化对象，即getBean()没有参数指定，外部化args为null，外部的args覆盖了bd.args。其中resolvedConstructorOrFactoryMethod用于缓存构造方法，constructorArgumentsResolved记录是否需要构造注入。如果缓存了构造方法，判断是否需要参数依赖注入，如果需要则调用autowireConstructor()，否则使用instantiateBean(). 当没有命中到缓存的构造方法，则寻找beanClass中有@Autowire的构造方法并将构造方法中的参数都实例化，调用autowireConstructor进行实例化，没有找到则使用类的默认有参和无参构造方法了，下面开始分析无参构造方法。 1234567891011121314151617181920protected BeanWrapper instantiateBean(String beanName, RootBeanDefinition mbd) &#123; try &#123; Object beanInstance; if (System.getSecurityManager() != null) &#123; beanInstance = AccessController.doPrivileged( (PrivilegedAction&lt;Object&gt;) () -&gt; getInstantiationStrategy().instantiate(mbd, beanName, this), getAccessControlContext()); &#125; else &#123; beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, this); &#125; BeanWrapper bw = new BeanWrapperImpl(beanInstance); initBeanWrapper(bw); return bw; &#125; catch (Throwable ex) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Instantiation of bean failed&quot;, ex); &#125; &#125; 主要是获取实例化策略然后实例化bean。Spring提供了两个实例化策略：SimpleInstantiationStrategy 和CglibSubclassingInstantiationStrategy。Spring默认是使用CglibSubclassingInstantiationStrategy，主要是解决replaced-method 或 lookup-method 标签。不过平时开发不会用到，我们主要看SimpleInstantiationStrategy#instantiate方法，主要是将构造器设置为可见，并且使用java反射来创建对象。 对象实例化完成后，通过BeanWrapper进行对bean的属性进行包装，BeanWrapperImpl是BeanWrapper的默认实现，提供了许多默认的属性编辑器，可以支持多种数据类型转换，用户也可以进行自定义。 当bean实现了MergedBeanDefinitionPostProcessor，bean实例化会执行回调。 为了解决bean的循环引用，bean实例化完成后，会将bean提前曝光，将bean的放入三级缓存，从二级缓存中删除。 提前曝光条件： bean是单例 bean允许循环依赖 bean的状态正在创建 Bean属性注入bean实例化后就要进行属性注入了，调用方法在populateBean(). 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) &#123; if (bw == null) &#123; if (mbd.hasPropertyValues()) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;); &#125; else &#123; // Skip property population phase for null instance. return; &#125; &#125; // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the // state of the bean before properties are set. This can be used, for example, // to support styles of field injection. InstantiationAwareBeanPostProcessors 实现类增强属性注入 if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123; for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123; if (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123; return; &#125; &#125; &#125; PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null); int resolvedAutowireMode = mbd.getResolvedAutowireMode(); // 从这里就可以看出Spring属性注入为ByName和ByType if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123; MutablePropertyValues newPvs = new MutablePropertyValues(pvs); // Add property values based on autowire by name if applicable. if (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123; autowireByName(beanName, mbd, bw, newPvs); &#125; // Add property values based on autowire by type if applicable. if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123; autowireByType(beanName, mbd, bw, newPvs); &#125; pvs = newPvs; &#125; boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors(); boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE); PropertyDescriptor[] filteredPds = null; if (hasInstAwareBpps) &#123; if (pvs == null) &#123; pvs = mbd.getPropertyValues(); &#125; for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123; PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName); if (pvsToUse == null) &#123; if (filteredPds == null) &#123; filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); &#125; pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvsToUse == null) &#123; return; &#125; &#125; pvs = pvsToUse; &#125; &#125; if (needsDepCheck) &#123; if (filteredPds == null) &#123; filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); &#125; checkDependencies(beanName, mbd, filteredPds, pvs); &#125; if (pvs != null) &#123; applyPropertyValues(beanName, mbd, bw, pvs); &#125; &#125; 从方法中可以看出bean的属性依赖注入主要是byName和byType，对应于@Autowire和@Qualifier，从BeanWrapper中找到不是简单属性的属性，然后根据注入类型来进行注入，byName主要是通过getBean从缓存中获取属性值，byType则根据依赖属性的类型的信息来创建对象。 1234567891011121314151617181920212223public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName, @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException &#123; descriptor.initParameterNameDiscovery(getParameterNameDiscoverer()); if (Optional.class == descriptor.getDependencyType()) &#123; return createOptionalDependency(descriptor, requestingBeanName); &#125; else if (ObjectFactory.class == descriptor.getDependencyType() || ObjectProvider.class == descriptor.getDependencyType()) &#123; return new DependencyObjectProvider(descriptor, requestingBeanName); &#125; else if (javaxInjectProviderClass == descriptor.getDependencyType()) &#123; return new Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName); &#125; else &#123; Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary( descriptor, requestingBeanName); if (result == null) &#123; result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter); &#125; return result; &#125; &#125; 在doResolveDependency中会根据注入的类转换成beanName，然后根据beanName在整个beanFactory中查找，找到具体的bean后通过反射，对属性进行赋值。 AutowiredAnnotationBeanPostProcessor#inject 12345678910111213141516171819202122232425262728protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable &#123; if (checkPropertySkipping(pvs)) &#123; return; &#125; Method method = (Method) this.member; Object[] arguments; if (this.cached) &#123; try &#123; arguments = resolveCachedArguments(beanName); &#125; catch (NoSuchBeanDefinitionException ex) &#123; // Unexpected removal of target bean for cached argument -&gt; re-resolve arguments = resolveMethodArguments(method, bean, beanName); &#125; &#125; else &#123; arguments = resolveMethodArguments(method, bean, beanName); &#125; if (arguments != null) &#123; try &#123; ReflectionUtils.makeAccessible(method); method.invoke(bean, arguments); &#125; catch (InvocationTargetException ex) &#123; throw ex.getTargetException(); &#125; &#125; &#125; 如果byName和byType无法依赖注入时，会执行applyPropertyValues方法，具体会从PropertyValues中找到对应的name和value来循环赋值。 Bean初始化接下来进行bean的初始化了，初始化主要在initializeBean方法中 1234567891011121314151617181920212223242526272829303132333435protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123; // 激活aware接口方法 invokeAwareMethods(beanName, bean); return null; &#125;, getAccessControlContext()); &#125; else &#123; // 对特殊的bean处理 实现Aware接口 调用 BeanNameAware BeanClassLoaderAware BeanFactoryAware接口方法 invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; // 前置调用，调用用户自己实现的BeanPostProcessor的postProcessBeforeInitialization，控制bean实例化后的前置其他操作 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; // 调用用户自定义的init方法，实现了InitializingBean并且重写了afterPropertiesSet方法 invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, &quot;Invocation of init method failed&quot;, ex); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; // 后置调用，调用用户自己实现的BeanPostProcessor的postProcessAfterInitialization，控制bean实例化后的前置其他操作 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean; &#125; 这里首先对实现了Aware相关接口（BeanNameAware， BeanClassLoaderAware， BeanFactoryAware）的bean进行aware方法的调用。然后对实现了BeanPostProcessor的bean的前置调用，接着调用InitializingBean#afterPropertySet()和用户自定义的init-method方法，最后执行BeanPostProcessor的后置调用。 bean的实例化，属性注入，初始化结束后，对创建bean执行后置调用，从正在创建bean的缓存singletonsCurrentlyInCreation中移除当前bean，然后将bean放入到一级缓存中，从三级缓存删除，二级缓存删除，注册到已经实例化完成的缓存registeredSingletons中去。 至此，bean在容器中可以被使用了，当bean容器销毁时，会调用对应的销毁逻辑。bean的实例化流程分析完成，其中细节可能无法尽说，感兴趣者可以自行阅读源码。 总结从整个Spring的bean生命周期来看，bean总共经历了这几个步骤： 从xml或注解中解析出bean的基本信息，封装成一个BeanDefinition 将BeanDefinition及其双亲信息封装到RootDefinition中 解析出beanClass及其对应的构造器，通过有参或者无参构造方法进行实例化 实例化后的bean进行属性注入，主要是byName和byType或者是通过PropertyValue来通过反射赋值 接着执行bean的初始化，主要是调用aware接口方法，BeanPostProcessor的前置调用，InitializingBean#afterPropertySet调用，init-method调用，BeanPostProcessor的后置调用 现在bean可以在容器中被使用了 bean的销毁操作","categories":[{"name":"Spring","slug":"Spring","permalink":"http://andrew9980.github.io/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://andrew9980.github.io/tags/Spring/"},{"name":"源码","slug":"源码","permalink":"http://andrew9980.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"3-Spring源码解析-Bean加载流程","slug":"3-Spring源码解析-Bean加载流程","date":"2022-01-05T09:18:32.000Z","updated":"2022-01-05T09:27:26.843Z","comments":true,"path":"2022/01/05/3-Spring源码解析-Bean加载流程/","link":"","permalink":"http://andrew9980.github.io/2022/01/05/3-Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Bean%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/","excerpt":"","text":"了解Spring的资源加载原理后，我们就可以分析Spring是如何解析xml加载bean了，我们首先创建User类 1234567891011121314151617public class User &#123; private String name; private Integer age; public void setAge(Integer age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public Integer getAge() &#123; return age; &#125;&#125; 然后在resource下创建一个application.xml 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;address&quot; class=&quot;com.andrew.study.domain.Address&quot;&gt; &lt;property name=&quot;province&quot; value=&quot;湖北&quot; /&gt; &lt;property name=&quot;city&quot; value=&quot;武汉&quot; /&gt; &lt;/bean&gt; &lt;bean id = &quot;user&quot; class=&quot;com.andrew.study.domain.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Andrew&quot; /&gt; &lt;property name=&quot;age&quot; value=&quot;24&quot; /&gt; &lt;property name=&quot;address&quot; value=&quot;address&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 测试代码： 12345678public static void main(String[] args) throws IOException &#123; DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); XmlBeanDefinitionReader definitionReader = new XmlBeanDefinitionReader(beanFactory); ClassPathResource resource = new ClassPathResource(&quot;application.xml&quot;); definitionReader.loadBeanDefinitions(resource); Object user = beanFactory.getBean(&quot;user&quot;); System.out.println(user.toString());&#125; 流程： 创建出Spring容器beanFactory 创建xml读取器并注册beanFactory 创建文件资源ClasspathResource 读取器加载文件资源注册到Spring容器中 从Spring容器获取name=user的bean 打印bean 一、创建BeanFactory首先从获取beanFactory分析 看一下结构图： BeanFactory作为Spring容器，提供了一系列获取Bean的方法，HierarchicalBeanFactory继承并强化了，提供了获取parentBeanFactory方法，ConfigurableBeanFactory则是提供了配置BeanFactory的一系列方法,AutowireCapableBeanFactory直接继承BeanFactory，提供了自动注入功能，并且提前暴露已经存在的bean实例。ListableBeanFactory用于枚举出BeanFactory中所有的Bean，而不用BeanFactory获取Bean要一个一个的getBean，ConfigurableListableBeanFactory同时继承了ListableBeanFactory，ConfigurableBeanFactory，AutowireCapatableBeanFactory，提供分析和修改Bean和预实例化Bean的功能。xxxRegister接口和类提供了对Bean的注册功能，DefaultListableeBeanFactory继承并实现了ConfigurableListableBeanFactory和AbstractAutowireCapatableBeanFactory以及BeanDefinitionRegister，相当于BeanFactory系列功能集大成者，所以我们通过此类来创建出我们的BeanFactory。 二、Xml加载及解析XmlBeanDefinitionReader用于将xml配置文件加载并注册成BeanDefinition，不过我们先创建出对象，在构造方法中传入我们的BeanDefinitionRegister对象。因为DefaultListableeBeanFactory作为BeanDefinitionRegister实现类，因此可以把它传入。 123public XmlBeanDefinitionReader(BeanDefinitionRegistry registry) &#123; super(registry);&#125; 我们进入super方法，因为XmlBeanDefinitionReader继承了AbstractBeanDefinitionReader，我们看看他的构造方法. 1234567891011121314151617181920protected AbstractBeanDefinitionReader(BeanDefinitionRegistry registry) &#123; Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;); this.registry = registry; // Determine ResourceLoader to use. if (this.registry instanceof ResourceLoader) &#123; this.resourceLoader = (ResourceLoader) this.registry; &#125; else &#123; this.resourceLoader = new PathMatchingResourcePatternResolver(); &#125; // Inherit Environment if possible if (this.registry instanceof EnvironmentCapable) &#123; this.environment = ((EnvironmentCapable) this.registry).getEnvironment(); &#125; else &#123; this.environment = new StandardEnvironment(); &#125;&#125; 首先判断传入的regiser是否是ResourceLoader，如果是可以直接使用当前的resourceLoader，不是则使用PathMatchimingResourcePatternResolver用来加载文件，关于ResourceLoader不清楚，可以看上一讲。之后ResourceLoader后再来指定当前的环境，先判断registry是否是EnvironmentCapable，不是则按照标准环境策略加载。 Environment用来指定当前的Spring容器运行在什么样的环境中，我们配置的spring.profiles.active=dev就是用来指定当前的Spring基于哪个配置文件来加载。 配置好BeanFactory和ResourceLoader后，我用来指定加载资源，并执行加载，将配置文件中的转为BeanDefinition 12ClassPathResource resource = new ClassPathResource(&quot;application.xml&quot;);definitionReader.loadBeanDefinitions(resource); 看一下loadBeanDefinitions(resource)如何实现的。 1234567891011121314151617181920212223242526272829303132333435public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123; return loadBeanDefinitions(new EncodedResource(resource));&#125;public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123; Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;); if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Loading XML bean definitions from &quot; + encodedResource); &#125; Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (!currentResources.add(encodedResource)) &#123; throw new BeanDefinitionStoreException( &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;); &#125; try (InputStream inputStream = encodedResource.getResource().getInputStream()) &#123; InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) &#123; inputSource.setEncoding(encodedResource.getEncoding()); &#125; return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException( &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex); &#125; finally &#123; currentResources.remove(encodedResource); if (currentResources.isEmpty()) &#123; this.resourcesCurrentlyBeingLoaded.remove(); &#125; &#125;&#125; 首先将我们的Resource进行编码，避免乱码。首先是获取正在加载的Resource，从encodedResource中获取InputStream，然后进入doLoadBeanDefinitions。 1234567891011121314151617181920212223242526272829303132333435protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException &#123; try &#123; Document doc = doLoadDocument(inputSource, resource); int count = registerBeanDefinitions(doc, resource); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Loaded &quot; + count + &quot; bean definitions from &quot; + resource); &#125; return count; &#125; catch (BeanDefinitionStoreException ex) &#123; throw ex; &#125; catch (SAXParseException ex) &#123; throw new XmlBeanDefinitionStoreException(resource.getDescription(), &quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex); &#125; catch (SAXException ex) &#123; throw new XmlBeanDefinitionStoreException(resource.getDescription(), &quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex); &#125; catch (ParserConfigurationException ex) &#123; throw new BeanDefinitionStoreException(resource.getDescription(), &quot;Parser configuration exception parsing XML from &quot; + resource, ex); &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException(resource.getDescription(), &quot;IOException parsing XML document from &quot; + resource, ex); &#125; catch (Throwable ex) &#123; throw new BeanDefinitionStoreException(resource.getDescription(), &quot;Unexpected exception parsing XML document from &quot; + resource, ex); &#125;&#125; 进入doLoadDocument 1234567891011protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception &#123; /** * inputSource：document资源 * getEntityResolver()得到entityResolver用于文档的验证 * errorHandler：sax的error处理器 * getValidationModeForResource(resource) xml文档的验证模式，默认模式是自动，XmlValidationModeDetector.VALIDATION_AUTO * namespaceAware 表示是否开启自动感知名称空间 */ return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler, getValidationModeForResource(resource), isNamespaceAware());&#125; 上面注释很清楚了，就是将当前文件资源解析成Document对象便于后面的解析。我们进入registerBeanDefinitions方法。 123456public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123; BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); int countBefore = getRegistry().getBeanDefinitionCount(); documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore;&#125; 首先创建BeanDefinitionDocumentReader对象，然后获取当前容器中存在的BeanDefinition数量。我们进入registerBeanDefinitions方法 123456789101112131415161718192021222324252627282930313233343536public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123; this.readerContext = readerContext; // doc.getDocumentElement() -&gt; CoreDocumentImpl#getDocumentElement() doRegisterBeanDefinitions(doc.getDocumentElement());&#125;protected void doRegisterBeanDefinitions(Element root) &#123; BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) &#123; String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) &#123; String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); // We cannot use Profiles.of(...) since profile expressions are not supported // in XML config. See SPR-12458 for details. if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec + &quot;] not matching: &quot; + getReaderContext().getResource()); &#125; return; &#125; &#125; &#125; // 前置处理xml标签的数据 preProcessXml(root); // 处理import alias bean 标签 parseBeanDefinitions(root, this.delegate); // 后置处理xml标签的数据 postProcessXml(root); this.delegate = parent;&#125; 我们主要看parseBeanDefinitions方法 1234567891011121314151617181920protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; if (delegate.isDefaultNamespace(root)) &#123; NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (node instanceof Element) &#123; Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) &#123; parseDefaultElement(ele, delegate); &#125; else &#123; delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; delegate.parseCustomElement(root); &#125;&#125; 这里就是拿到Document的Element然后遍历Element下面的Node，我们写的标签,就相当于一个Node，解析方法在parseDefaultElement中。 123456789101112131415private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123; if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; importBeanDefinitionResource(ele); &#125; else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; processAliasRegistration(ele); &#125; else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; processBeanDefinition(ele, delegate); &#125; else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123; // recurse doRegisterBeanDefinitions(ele); &#125;&#125; 这里我们就能看到处理了, , , 标签，我们这里只分析,其他的大同小异, 进入processBeanDefinition方法。 12345678910111213141516protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123; BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) &#123; bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try &#123; // Register the final decorated instance. BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); &#125; catch (BeanDefinitionStoreException ex) &#123; getReaderContext().error(&quot;Failed to register bean definition with name &#x27;&quot; + bdHolder.getBeanName() + &quot;&#x27;&quot;, ele, ex); &#125; // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); &#125;&#125; 这里首先就是根据element来解析，调用parseBeanDefinitionElement 123public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) &#123; return parseBeanDefinitionElement(ele, null);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) &#123; //&lt;bean&gt; 的id和name属性值 String id = ele.getAttribute(ID_ATTRIBUTE); String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); List&lt;String&gt; aliases = new ArrayList&lt;&gt;(); if (StringUtils.hasLength(nameAttr)) &#123; String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); &#125; String beanName = id; if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123; beanName = aliases.remove(0); if (logger.isTraceEnabled()) &#123; logger.trace(&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot; + beanName + &quot;&#x27; as bean name and &quot; + aliases + &quot; as aliases&quot;); &#125; &#125; if (containingBean == null) &#123; checkNameUniqueness(beanName, aliases, ele); &#125; // 解析&lt;bean&gt; AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); if (beanDefinition != null) &#123; if (!StringUtils.hasText(beanName)) &#123; try &#123; if (containingBean != null) &#123; beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); &#125; else &#123; beanName = this.readerContext.generateBeanName(beanDefinition); // Register an alias for the plain bean class name, if still possible, // if the generator returned the class name plus a suffix. // This is expected for Spring 1.2/2.0 backwards compatibility. String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123; aliases.add(beanClassName); &#125; &#125; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot; + &quot;using generated bean name [&quot; + beanName + &quot;]&quot;); &#125; &#125; catch (Exception ex) &#123; error(ex.getMessage(), ele); return null; &#125; &#125; String[] aliasesArray = StringUtils.toStringArray(aliases); return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); &#125; return null;&#125; 接下来就是从element中获取值了，然后检查beanName和alias是否唯一处理，接着将bean标签注册成一个AbstractBeanDefinition。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, @Nullable BeanDefinition containingBean) &#123; this.parseState.push(new BeanEntry(beanName)); String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123; className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); &#125; String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123; parent = ele.getAttribute(PARENT_ATTRIBUTE); &#125; try &#123; AbstractBeanDefinition bd = createBeanDefinition(className, parent); // 给定className创建一个BeanDefinition // 给beanDefinition属性赋值 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); // &lt;meta&gt; 标签赋值 parseMetaElements(ele, bd); parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); // &lt;constructor-arg&gt; 解析 parseConstructorArgElements(ele, bd); // &lt;property&gt; 解析 parsePropertyElements(ele, bd); // &lt;qualifier&gt; 解析 parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; &#125; catch (ClassNotFoundException ex) &#123; error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex); &#125; catch (NoClassDefFoundError err) &#123; error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err); &#125; catch (Throwable ex) &#123; error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex); &#125; finally &#123; this.parseState.pop(); &#125; return null;&#125; 首先标识当前beanName正在被解析，然后获取class和parent属性，根据className创建一个GenericBeanDefinition 12345678910111213141516171819202122protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName) throws ClassNotFoundException &#123; return BeanDefinitionReaderUtils.createBeanDefinition( parentName, className, this.readerContext.getBeanClassLoader());&#125;public static AbstractBeanDefinition createBeanDefinition( @Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader) throws ClassNotFoundException &#123; GenericBeanDefinition bd = new GenericBeanDefinition(); bd.setParentName(parentName); if (className != null) &#123; if (classLoader != null) &#123; bd.setBeanClass(ClassUtils.forName(className, classLoader)); &#125; else &#123; bd.setBeanClassName(className); &#125; &#125; return bd;&#125; GenericBeanDefinition是一个标准的BeanDefinition，里面定义了许多有关Bean的属性并有默认值。我们得到标准BeanDefinition后，解析的其他属性，singleton，scop，abstract等等，解析方法在parseBeanDefinitionAttributes中。然后解析的内部标签，,, ,，代码比较简单就不列出了。解析完毕后将我们得到的BeanDefinition返回，然后将当前bean的解析状态删除。 后面根据bean是否有父类和是否是FactoryBean初始化一下beanName，最后根据beanDefintion，beanName，beanClassName创建BeanDefinitionHolder返回。 BeanDefinitionHolder是BeanDefinition的持有类，拥有beanName和alias属性，可以作为占位符注册一个内部bean。 拿到BeanDefinitionHolder后，bean是否需要装饰，最后将bean在BeanFactory中注册。我们开始分析注册方法registerBeanDefinition 12345678910111213141516public static void registerBeanDefinition( BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException &#123; // Register bean definition under primary name. String beanName = definitionHolder.getBeanName(); registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); // Register aliases for bean name, if any. String[] aliases = definitionHolder.getAliases(); if (aliases != null) &#123; for (String alias : aliases) &#123; registry.registerAlias(beanName, alias); &#125; &#125;&#125; 首先从BeanDefinitionHolder中获取beanName，然后注册到BeanFactory中，最后将beanName和alias映射，我们详细看一下bean的注册逻辑。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException &#123; Assert.hasText(beanName, &quot;Bean name must not be empty&quot;); Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;); if (beanDefinition instanceof AbstractBeanDefinition) &#123; try &#123; ((AbstractBeanDefinition) beanDefinition).validate(); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, &quot;Validation of bean definition failed&quot;, ex); &#125; &#125; BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName); if (existingDefinition != null) &#123; if (!isAllowBeanDefinitionOverriding()) &#123; throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition); &#125; else if (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123; // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE if (logger.isInfoEnabled()) &#123; logger.info(&quot;Overriding user-defined bean definition for bean &#x27;&quot; + beanName + &quot;&#x27; with a framework-generated bean definition: replacing [&quot; + existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;); &#125; &#125; else if (!beanDefinition.equals(existingDefinition)) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Overriding bean definition for bean &#x27;&quot; + beanName + &quot;&#x27; with a different definition: replacing [&quot; + existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;); &#125; &#125; else &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Overriding bean definition for bean &#x27;&quot; + beanName + &quot;&#x27; with an equivalent definition: replacing [&quot; + existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;); &#125; &#125; this.beanDefinitionMap.put(beanName, beanDefinition); &#125; else &#123; if (hasBeanCreationStarted()) &#123; // Cannot modify startup-time collection elements anymore (for stable iteration) synchronized (this.beanDefinitionMap) &#123; this.beanDefinitionMap.put(beanName, beanDefinition); List&lt;String&gt; updatedDefinitions = new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; removeManualSingletonName(beanName); &#125; &#125; else &#123; // Still in startup registration phase this.beanDefinitionMap.put(beanName, beanDefinition); this.beanDefinitionNames.add(beanName); removeManualSingletonName(beanName); &#125; this.frozenBeanDefinitionNames = null; &#125; if (existingDefinition != null || containsSingleton(beanName)) &#123; resetBeanDefinition(beanName); &#125; else if (isConfigurationFrozen()) &#123; clearByTypeCache(); &#125;&#125; 首先判断BeanDefinition是否是AbstractBeanDefinition类型，如果是，则进行校验。然后从beanDefinitionMap（存储已经注册完成的Bean）中查找当前的beanName是否已经注册，如果存在则判断当前容器是否允许相同beanName的beanDefinition覆盖，判断优先级，判断两个BeanDefinition是否相同，最后将BeanDefinition放入到beanDefinitionMap中。如果不存在，判断bean是否正在被创建，然后直接将bean放入到beanDefinitionMap中，然后手动删除正在注册的beanName，manualSingletonNames中存储的是手动注册创建的单例bean。最后如果有存在的Bean则将bean的缓存重置，并在上下文发送注册完成事件。 最后我们回顾一下registerBeanDefinitions方法，注册完成后，重新获取BeanDefinitionMap的size，减去之前的BeanDefinition数量，返回此次注册BeanDefinition的数量。 123456public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123; BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); int countBefore = getRegistry().getBeanDefinitionCount(); documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore;&#125; 至此，我们Bean的加载分析完毕，下面开始总结。 总结 我们常说的Spring的Bean其实是一个BeanDefinition对象，BeanDefinition对象用来描述我们的Bean，包括我们熟知的一些属性，beanName，className，scope，autowireType等等。 Spring容器内部维持了一个BeanDefinitionMap，当我们注册后，可以直接从BeanDefinitionMap中获取BeanDefinition，不用重复解析xml文档提升效率。 可以看见，Spring解析xml其实用到的就是我们熟知的一些技术，Spring并不可怕，持之以恒。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://andrew9980.github.io/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://andrew9980.github.io/tags/Spring/"},{"name":"源码","slug":"源码","permalink":"http://andrew9980.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"2.Spring源码解析-统一资源管理","slug":"2-Spring源码解析-统一资源管理","date":"2022-01-05T09:00:00.000Z","updated":"2022-01-30T08:39:13.982Z","comments":true,"path":"2022/01/05/2-Spring源码解析-统一资源管理/","link":"","permalink":"http://andrew9980.github.io/2022/01/05/2-Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/","excerpt":"","text":"了解了Spring IOC的概念后，由于Spring容器需要从配置文件中读取bean，所以我们从Spring文件资源加载开始，首先了解Spring的文件资源是什么样子的。 ![](2-Spring源码解析-统一资源管理/Spring Resource Class.png) Spring将文件资源抽象成两种，分别是文件描述和文件加载，对应接口为Resource和ResourceLoader Resource接口： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public interface Resource extends InputStreamSource &#123; /** 判断resource在物理路径下是否存在 */ boolean exists(); /** 文件是否可读，需要首选判断文件是否存在 */ default boolean isReadable() &#123; return exists(); &#125; /** 判断文件是否被打开，如果为true，则inputStream不能多次读取，并且读取完后需要close，避免文件泄漏 */ default boolean isOpen() &#123; return false; &#125; /** 判断在文件系统中resource是否是一个文件，getFile可以获取这个文件 */ default boolean isFile() &#123; return false; &#125; /** 返回当前resource的URL，如果不能用url表示，则报错 */ URL getURL() throws IOException; /** 返回当前resource的URI，如果不能用uri表示，则报错 */ URI getURI() throws IOException; /** 返回Resource代表的file */ File getFile() throws IOException; /** 返回ReadableByteChannel */ default ReadableByteChannel readableChannel() throws IOException &#123; return Channels.newChannel(getInputStream()); &#125; /** 返回文件内容长度 */ long contentLength() throws IOException; /** 返回文件最后修改的时间戳 */ long lastModified() throws IOException; /** 创建相对路径下的resource */ Resource createRelative(String relativePath) throws IOException; /** 文件名 */ @Nullable String getFilename(); /** 文件描述 */ String getDescription();&#125; Resource接口抽象了一系列关于描述文件的方法，其实现类或子接口提供了不同的功能。 WritableResource 增加可写功能 ContextResource 增加上下文功能，可以读取ServletContextResource资源 UrlResource 支持URL和File方式访问 FileUrlResource UrlResource实现类，支持file方式访问 FileSystemResource WritableResource实现类，同时支持url和file方式访问 ClassPathResource classpath路径访问文件 ByteArrayResource 字节数组资源访问 InputStreamResource inputStream访问 ResourceUtils定义了可能访问到的文件类型。 1234567891011121314151617181920212223242526272829303132333435363738394041public abstract class ResourceUtils &#123;/** Pseudo URL prefix for loading from the class path: &quot;classpath:&quot;. */public static final String CLASSPATH_URL_PREFIX = &quot;classpath:&quot;;/** URL prefix for loading from the file system: &quot;file:&quot;. */public static final String FILE_URL_PREFIX = &quot;file:&quot;;/** URL prefix for loading from a jar file: &quot;jar:&quot;. */public static final String JAR_URL_PREFIX = &quot;jar:&quot;;/** URL prefix for loading from a war file on Tomcat: &quot;war:&quot;. */public static final String WAR_URL_PREFIX = &quot;war:&quot;;/** URL protocol for a file in the file system: &quot;file&quot;. */public static final String URL_PROTOCOL_FILE = &quot;file&quot;;/** URL protocol for an entry from a jar file: &quot;jar&quot;. */public static final String URL_PROTOCOL_JAR = &quot;jar&quot;;/** URL protocol for an entry from a war file: &quot;war&quot;. */public static final String URL_PROTOCOL_WAR = &quot;war&quot;;/** URL protocol for an entry from a zip file: &quot;zip&quot;. */public static final String URL_PROTOCOL_ZIP = &quot;zip&quot;;/** URL protocol for an entry from a WebSphere jar file: &quot;wsjar&quot;. */public static final String URL_PROTOCOL_WSJAR = &quot;wsjar&quot;;/** URL protocol for an entry from a JBoss jar file: &quot;vfszip&quot;. */public static final String URL_PROTOCOL_VFSZIP = &quot;vfszip&quot;;/** URL protocol for a JBoss file system resource: &quot;vfsfile&quot;. */public static final String URL_PROTOCOL_VFSFILE = &quot;vfsfile&quot;;/** URL protocol for a general JBoss VFS resource: &quot;vfs&quot;. */public static final String URL_PROTOCOL_VFS = &quot;vfs&quot;;/** File extension for a regular jar file: &quot;.jar&quot;. */public static final String JAR_FILE_EXTENSION = &quot;.jar&quot;;&#125; ResourceLoader接口： Spring统一了加载资源策略，用ResourceLoader接口以加载classpath协议(classpath:xxxx.xml)或者file system(file:/xxxx/xxxx/xxx.xml)协议的文件。其中加载文件的核心方法是getResource，通过传入的文件路径，转变成Resource。 12345678910111213public interface ResourceLoader &#123; /** classpath前缀常量 引用 ResourceUtils.CLASSPATH_URL_PREFIX -&gt; &quot;classpath:&quot;*/ String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX; /** 通过给定的location返回resource，不确定是否存在，需要调用exsist */ Resource getResource(String location); /** 获取当前文件的ClassLoader 一般默认为Thread.currentThread() */ @Nullable ClassLoader getClassLoader();&#125; DefaultResourceLoader是ResourceLoader的默认实现，其getResource方法则是核心的文件加载策略。 1234567891011121314151617181920212223242526272829303132// DefaultResourceLoader#getResourcepublic Resource getResource(String location) &#123; Assert.notNull(location, &quot;Location must not be null&quot;); // 自定义协议 for (ProtocolResolver protocolResolver : getProtocolResolvers()) &#123; Resource resource = protocolResolver.resolve(location, this); if (resource != null) &#123; return resource; &#125; &#125; // location是/开头则默认调用ClassPathContextResource if (location.startsWith(&quot;/&quot;)) &#123; return getResourceByPath(location); &#125; // location是classpath:开头 else if (location.startsWith(CLASSPATH_URL_PREFIX)) &#123; return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader()); &#125; else &#123; try &#123; // Try to parse the location as a URL... // url 协议 URL url = new URL(location); return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url)); &#125; catch (MalformedURLException ex) &#123; // No URL -&gt; resolve as resource path. // 不是url协议还是使用ClassPathContextResource return getResourceByPath(location); &#125; &#125;&#125; 首先获取自定义的协议解析器，如果存在则通过实现的resolve方法加载文件。（后文详谈） 1234private final Set&lt;ProtocolResolver&gt; protocolResolvers = new LinkedHashSet&lt;&gt;(4);public Collection&lt;ProtocolResolver&gt; getProtocolResolvers() &#123; return this.protocolResolvers;&#125; 如果没有自定义的协议解析器或者加载不到当前文件的协议，则判断路径是否是/开头，如果是则按照classpath:协议加载并且具有上下文功能 123protected Resource getResourceByPath(String path) &#123; return new ClassPathContextResource(path, getClassLoader());&#125; 然后判断是否是classpath:开头，如果是则按照classpath:协议加载。如果都不是则按照url协议解析，如果不是url协议，则抛出错误，在异常处理中，最后还是按照classpath:协议加载并且具有上下文功能。 其中getResourceByPath为将给的路径转成一个Resource的绑定，默认实现是按照classpath上下文解析，如果文件是file或者web协议则解析出错，因此FileSystemXmlApplicationContext和XmlWebApplicationContext继承了DefaultResourceLoader并覆盖了getResourceByPath实现。 1234567// FileSystemXmlApplicationContext#getResourceByPathprotected Resource getResourceByPath(String path) &#123; if (path.startsWith(&quot;/&quot;)) &#123; path = path.substring(1); &#125; return new FileSystemResource(path);&#125; 123456// XmlWebApplicationContext extends AbstractRefreshableWebApplicationContext// AbstractRefreshableWebApplicationContext#getResourceByPathprotected Resource getResourceByPath(String path) &#123; Assert.state(this.servletContext != null, &quot;No ServletContext available&quot;); return new ServletContextResource(this.servletContext, path);&#125; 前面提到ProtocolResolver接口是提供协议解析，用户可以自定义协议并且实现resovle方法用于解析逻辑。 123456@FunctionalInterfacepublic interface ProtocolResolver &#123; @Nullable Resource resolve(String location, ResourceLoader resourceLoader);&#125; 示例： 1234567DefaultResourceLoader resourceLoader = new DefaultResourceLoader();resourceLoader.addProtocolResolver((location, resourceLoader1) -&gt; &#123; if (!location.startsWith(&quot;path:&quot;)) return null; String substring = location.substring(5); return resourceLoader1.getResource(&quot;classpath:&quot; + substring);&#125;); 由于ProtocolResovler是函数式接口，这里直接调用DefalutResourceLoader的addProtocolResovler方法使用lambda表达式创建一个ProtocolResovler的实现。 这里自定义path:前缀的协议，并将path截取后改为classpath:协议。具体逻辑用户可以根据业务需要自行编写。 由于ResourceLoader接口的getResource只能读取单个文件，当需要批量读取文件时显得不足。因此ResourcePatternResolver 继承ResourceLoader提供了getResources，通过传入的locationPattern参数，使用Ant风格用于匹配多个文件后加载。 Apache Ant风格： ? 同一通配任意单个字符 * 同一通配任意多个字符 ** 通配多个目录下的任意字符 示例： classpath:?.xml 通配classpath路径下x.xml文件 classpath:*.xml 通配classpath路径下以.xml为后缀的文件 com/andrew/**/*.xml 通配以com/andrew开头的文件夹下的所有xml后缀文件 ResourcePatternResolver接口： 12345678public interface ResourcePatternResolver extends ResourceLoader &#123; /** classpath路径通配符常量：classpath*: */ String CLASSPATH_ALL_URL_PREFIX = &quot;classpath*:&quot;; /** 解析给定的路径通配符加载多个文件 */ Resource[] getResources(String locationPattern) throws IOException;&#125; PathMatchingResourcePatternResovler实现ResourcePatterResovler，加载策略代码： 12345678910111213141516171819202122232425262728293031public Resource[] getResources(String locationPattern) throws IOException &#123; Assert.notNull(locationPattern, &quot;Location pattern must not be null&quot;); // 首先判断是否是classpath*:前缀 if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123; // 通过classpath查找 // a class path resource (multiple resources for same name possible) // 判断是否是classpath*:开头 if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123; // a class path resource pattern return findPathMatchingResources(locationPattern); &#125; else &#123; // all class path resources with the given name return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length())); &#125; &#125; else &#123; // 通过file查找 // Generally only look for a pattern after a prefix here, // and on Tomcat only after the &quot;*/&quot; separator for its &quot;war:&quot; protocol. int prefixEnd = (locationPattern.startsWith(&quot;war:&quot;) ? locationPattern.indexOf(&quot;*/&quot;) + 1 : locationPattern.indexOf(&#x27;:&#x27;) + 1); if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123; // a file pattern // 找匹配文件 return findPathMatchingResources(locationPattern); &#125; else &#123; // a single resource with the given name return new Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;; &#125; &#125;&#125; 首先判断是否是classpath*:开头，如果是再截去路径字符串classpath*:剩下的字符串是否符合ant风格，如果是则执行加载策略。 12345678910111213141516171819202122232425262728293031323334protected Resource[] findPathMatchingResources(String locationPattern) throws IOException &#123; // 文件夹最后一个目录 /static/*.xml 则rootDirPath=/static/ classpath*:*.xml rootDirPath=classpath*: String rootDirPath = determineRootDir(locationPattern); // 文件匹配，例如：*.xml String subPattern = locationPattern.substring(rootDirPath.length()); // 给定路径下的文件夹作为单个resource Resource[] rootDirResources = getResources(rootDirPath); Set&lt;Resource&gt; result = new LinkedHashSet&lt;&gt;(16); for (Resource rootDirResource : rootDirResources) &#123; rootDirResource = resolveRootDirResource(rootDirResource); // 当前文件夹在系统下的绝对路径 URL rootDirUrl = rootDirResource.getURL(); if (equinoxResolveMethod != null &amp;&amp; rootDirUrl.getProtocol().startsWith(&quot;bundle&quot;)) &#123; // 判断协议是否是bundle URL resolvedUrl = (URL) ReflectionUtils.invokeMethod(equinoxResolveMethod, null, rootDirUrl); if (resolvedUrl != null) &#123; rootDirUrl = resolvedUrl; &#125; rootDirResource = new UrlResource(rootDirUrl); &#125; if (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) &#123; // 判断协议是否是vfs result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirUrl, subPattern, getPathMatcher())); &#125; else if (ResourceUtils.isJarURL(rootDirUrl) || isJarResource(rootDirResource)) &#123; // 判断协议是否是jar result.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirUrl, subPattern)); &#125; else &#123; result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern)); &#125; &#125; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Resolved location pattern [&quot; + locationPattern + &quot;] to resources &quot; + result); &#125; return result.toArray(new Resource[0]);&#125; 首先找到文件的根目录，如果location是/static/.xml，则rootDirPath是/static/，如果是classpath: 则rootDirPath是classpath*: 如果是classpath*:static/.xml,则rootDirPath是classpath:static/ 1234567891011protected String determineRootDir(String location) &#123; int prefixEnd = location.indexOf(&#x27;:&#x27;) + 1; int rootDirEnd = location.length(); while (rootDirEnd &gt; prefixEnd &amp;&amp; getPathMatcher().isPattern(location.substring(prefixEnd, rootDirEnd))) &#123; rootDirEnd = location.lastIndexOf(&#x27;/&#x27;, rootDirEnd - 2) + 1; &#125; if (rootDirEnd == 0) &#123; rootDirEnd = prefixEnd; &#125; return location.substring(0, rootDirEnd);&#125; 然后截去根目录，得到通配符文件*.xml路径。然后调用getResources获取根目录下的所有文件夹作为Resource数组 12345678910111213141516171819202122232425262728293031public Resource[] getResources(String locationPattern) throws IOException &#123; Assert.notNull(locationPattern, &quot;Location pattern must not be null&quot;); // 首先判断是否是classpath*:前缀 if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123; // 通过classpath查找 // a class path resource (multiple resources for same name possible) // 判断是否是classpath*:开头 if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123; // a class path resource pattern return findPathMatchingResources(locationPattern); &#125; else &#123; // all class path resources with the given name return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length())); &#125; &#125; else &#123; // 通过file查找 // Generally only look for a pattern after a prefix here, // and on Tomcat only after the &quot;*/&quot; separator for its &quot;war:&quot; protocol. int prefixEnd = (locationPattern.startsWith(&quot;war:&quot;) ? locationPattern.indexOf(&quot;*/&quot;) + 1 : locationPattern.indexOf(&#x27;:&#x27;) + 1); if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123; // a file pattern // 找匹配文件 return findPathMatchingResources(locationPattern); &#125; else &#123; // a single resource with the given name return new Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;; &#125; &#125;&#125; 可以发现调用getResources其实是调用的findAllClassPathResources方法，用于将目录转变成Resource，如果是classpath*:.xml则加载类路径下的所有目录，main目录，resource目录，如果是classpath*:config/*.xml，则只有main/config/目录。 123456789101112131415161718192021222324252627protected Resource[] findAllClassPathResources(String location) throws IOException &#123; String path = location; if (path.startsWith(&quot;/&quot;)) &#123; path = path.substring(1); &#125; Set&lt;Resource&gt; result = doFindAllClassPathResources(path); if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Resolved classpath location [&quot; + location + &quot;] to resources &quot; + result); &#125; return result.toArray(new Resource[0]);&#125;protected Set&lt;Resource&gt; doFindAllClassPathResources(String path) throws IOException &#123; Set&lt;Resource&gt; result = new LinkedHashSet&lt;&gt;(16); ClassLoader cl = getClassLoader(); Enumeration&lt;URL&gt; resourceUrls = (cl != null ? cl.getResources(path) : ClassLoader.getSystemResources(path)); while (resourceUrls.hasMoreElements()) &#123; URL url = resourceUrls.nextElement(); result.add(convertClassLoaderURL(url)); &#125; if (!StringUtils.hasLength(path)) &#123; // The above result is likely to be incomplete, i.e. only containing file system references. // We need to have pointers to each of the jar files on the classpath as well... addAllClassLoaderJarRoots(cl, result); &#125; return result;&#125; 得到rootDirResources后，遍历判断各种文件协议bundle，vfs，jar及其他文件。这里只分析其他，接着进入doFindPathMatchingFileResources方法。 1234567891011121314151617181920212223protected Set&lt;Resource&gt; doFindPathMatchingFileResources(Resource rootDirResource, String subPattern) throws IOException &#123; File rootDir; try &#123; // 文件夹resource的绝对路径 rootDir = rootDirResource.getFile().getAbsoluteFile(); &#125; catch (FileNotFoundException ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Cannot search for matching files underneath &quot; + rootDirResource + &quot; in the file system: &quot; + ex.getMessage()); &#125; return Collections.emptySet(); &#125; catch (Exception ex) &#123; if (logger.isInfoEnabled()) &#123; logger.info(&quot;Failed to resolve &quot; + rootDirResource + &quot; in the file system: &quot; + ex); &#125; return Collections.emptySet(); &#125; return doFindMatchingFileSystemResources(rootDir, subPattern);&#125; 拿到当前目录下文件的绝对路径，如果没有文件则报错。然后进入doFindMatchingFileSystemResources 123456789101112protected Set&lt;Resource&gt; doFindMatchingFileSystemResources(File rootDir, String subPattern) throws IOException &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Looking for matching resources in directory tree [&quot; + rootDir.getPath() + &quot;]&quot;); &#125; // 找到文件路径下所有匹配到的文件 Set&lt;File&gt; matchingFiles = retrieveMatchingFiles(rootDir, subPattern); Set&lt;Resource&gt; result = new LinkedHashSet&lt;&gt;(matchingFiles.size()); for (File file : matchingFiles) &#123; result.add(new FileSystemResource(file)); &#125; return result;&#125; 12345678910111213141516171819202122232425262728293031323334protected Set&lt;File&gt; retrieveMatchingFiles(File rootDir, String pattern) throws IOException &#123; if (!rootDir.exists()) &#123; // Silently skip non-existing directories. if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Skipping [&quot; + rootDir.getAbsolutePath() + &quot;] because it does not exist&quot;); &#125; return Collections.emptySet(); &#125; if (!rootDir.isDirectory()) &#123; // Complain louder if it exists but is no directory. if (logger.isInfoEnabled()) &#123; logger.info(&quot;Skipping [&quot; + rootDir.getAbsolutePath() + &quot;] because it does not denote a directory&quot;); &#125; return Collections.emptySet(); &#125; if (!rootDir.canRead()) &#123; if (logger.isInfoEnabled()) &#123; logger.info(&quot;Skipping search for matching files underneath directory [&quot; + rootDir.getAbsolutePath() + &quot;] because the application is not allowed to read the directory&quot;); &#125; return Collections.emptySet(); &#125; String fullPattern = StringUtils.replace(rootDir.getAbsolutePath(), File.separator, &quot;/&quot;); // 如果通配文件没有/开头则加上 if (!pattern.startsWith(&quot;/&quot;)) &#123; fullPattern += &quot;/&quot;; &#125; // 拼接整个文件路径 /Users/andrew/Documents/projects/spring-framework/spring-study/build/resources/main/profile/*.xml fullPattern = fullPattern + StringUtils.replace(pattern, File.separator, &quot;/&quot;); Set&lt;File&gt; result = new LinkedHashSet&lt;&gt;(8); doRetrieveMatchingFiles(fullPattern, rootDir, result); return result;&#125; 主要进行文件夹过滤，和拼接整个文件的路径，然后进入真正执行的方法doRetrieveMatchingFiles 123456789101112131415161718192021222324protected void doRetrieveMatchingFiles(String fullPattern, File dir, Set&lt;File&gt; result) throws IOException &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Searching directory [&quot; + dir.getAbsolutePath() + &quot;] for files matching pattern [&quot; + fullPattern + &quot;]&quot;); &#125; for (File content : listDirectory(dir)) &#123; String currPath = StringUtils.replace(content.getAbsolutePath(), File.separator, &quot;/&quot;); // 判断是否是文件夹 if (content.isDirectory() &amp;&amp; getPathMatcher().matchStart(fullPattern, currPath + &quot;/&quot;)) &#123; if (!content.canRead()) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Skipping subdirectory [&quot; + dir.getAbsolutePath() + &quot;] because the application is not allowed to read the directory&quot;); &#125; &#125; else &#123; doRetrieveMatchingFiles(fullPattern, content, result); &#125; &#125; if (getPathMatcher().match(fullPattern, currPath)) &#123; result.add(content); &#125; &#125;&#125; listDirectory主要是列出当前目录下的所有文件，然后通过递归找出匹配的文件。最后将拿到的文件转成Resource数组。 上面的分析使用classpath*:协议，当我们不使用此前缀时，调用的还是findPathMatchingResources方法，这里再把代码贴出来 12345678910111213141516171819202122232425262728293031public Resource[] getResources(String locationPattern) throws IOException &#123; Assert.notNull(locationPattern, &quot;Location pattern must not be null&quot;); // 首先判断是否是classpath*:前缀 if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123; // 通过classpath查找 // a class path resource (multiple resources for same name possible) // 判断是否是classpath*:开头 if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123; // a class path resource pattern return findPathMatchingResources(locationPattern); &#125; else &#123; // all class path resources with the given name return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length())); &#125; &#125; else &#123; // 通过file查找 // Generally only look for a pattern after a prefix here, // and on Tomcat only after the &quot;*/&quot; separator for its &quot;war:&quot; protocol. int prefixEnd = (locationPattern.startsWith(&quot;war:&quot;) ? locationPattern.indexOf(&quot;*/&quot;) + 1 : locationPattern.indexOf(&#x27;:&#x27;) + 1); if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123; // a file pattern // 找匹配文件 return findPathMatchingResources(locationPattern); &#125; else &#123; // a single resource with the given name return new Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334protected Resource[] findPathMatchingResources(String locationPattern) throws IOException &#123; // 文件夹最后一个目录 /static/*.xml 则rootDirPath=/static/ classpath*:*.xml rootDirPath=classpath*: String rootDirPath = determineRootDir(locationPattern); // 文件匹配，例如：*.xml String subPattern = locationPattern.substring(rootDirPath.length()); // 给定路径下的文件夹作为单个resource Resource[] rootDirResources = getResources(rootDirPath); Set&lt;Resource&gt; result = new LinkedHashSet&lt;&gt;(16); for (Resource rootDirResource : rootDirResources) &#123; rootDirResource = resolveRootDirResource(rootDirResource); // 当前文件夹在系统下的绝对路径 URL rootDirUrl = rootDirResource.getURL(); if (equinoxResolveMethod != null &amp;&amp; rootDirUrl.getProtocol().startsWith(&quot;bundle&quot;)) &#123; // 判断协议是否是bundle URL resolvedUrl = (URL) ReflectionUtils.invokeMethod(equinoxResolveMethod, null, rootDirUrl); if (resolvedUrl != null) &#123; rootDirUrl = resolvedUrl; &#125; rootDirResource = new UrlResource(rootDirUrl); &#125; if (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) &#123; // 判断协议是否是vfs result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirUrl, subPattern, getPathMatcher())); &#125; else if (ResourceUtils.isJarURL(rootDirUrl) || isJarResource(rootDirResource)) &#123; // 判断协议是否是jar result.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirUrl, subPattern)); &#125; else &#123; result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern)); &#125; &#125; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Resolved location pattern [&quot; + locationPattern + &quot;] to resources &quot; + result); &#125; return result.toArray(new Resource[0]);&#125; 只不过在调用getResources(rootDirPath)时，实际调用的是new Resource[] {getResourceLoader().getResource(locationPattern)}，然后使用DefaultResourceLoader#getResource将路径转成Resource。后续逻辑和classpath*:一样，遍历Resource数组，然后从文件夹中取文件，最后将文件转成Resource数组返回。 加载文件源码分析完毕，最后总结一下： Resource抽象了文件的描述，ResourceLoader抽象了文件的加载 DefalutResourceLoader为ResourceLoader的默认实现，其getResource只能加载单一文件，ResourcePatternResovler继承ResourceLoader提供了getResources解析ant风格的路径来加载多个文件 PathMatchingResourcePatternResolver作为ResourcePatternResovler的实现类，提供了加载classpath*和file协议的策略","categories":[{"name":"Spring","slug":"Spring","permalink":"http://andrew9980.github.io/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://andrew9980.github.io/tags/Spring/"},{"name":"源码","slug":"源码","permalink":"http://andrew9980.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"1.Spring源码解析-概述","slug":"1-Spring源码解析-概述","date":"2022-01-05T08:55:04.000Z","updated":"2022-01-05T09:18:03.089Z","comments":true,"path":"2022/01/05/1-Spring源码解析-概述/","link":"","permalink":"http://andrew9980.github.io/2022/01/05/1-Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E6%A6%82%E8%BF%B0/","excerpt":"","text":"一、IOC（Inversion Of Control）在Java应用中的对象，在Spring中称为Bean。Spring通过控制反转（又称：依赖注入）来构建和管理bean的生命周期及依赖关系。 以前Java应用都是自身需要哪些对象，便直接在功能模块中使用new得到，造成对象之间的依赖关系过于复杂。Spring将这些对象通过元数据配置（xml配置，Java注解配置等）来构建和管理对象的依赖关系，将获取对象的方式从应用程序主动创建，改变成直接从Spring容器中获取。将对象的依赖关系解耦。 例如找对象，自己找到符合心意的对象比较困难，于是许多未婚男女都会去婚姻介绍所中登记自己的相关信息和求偶标准，然后委托介绍所来负责给他们找对象。当婚姻介绍所找到符合他们需要的对象时，直接通知他们找到了，然后A和B的依赖关系就达成了。 这里的婚姻介绍所就是Spring的容器。A和B相当于未婚男女，当A需要找B类型的对象B时，直接告诉容器，容器便会从登记册中找到B然后提供给A 12345Container（ &quot;A&quot;, &quot;B&quot;, &quot;C&quot;...） 123456@Componentpublic class A &#123; // 告诉Container需要B，Container则会找到B并初始化，注入到A中 @Autowired private B b;&#125; 二、IOC注入方式在Spring中，IOC的注入分为三种：构造方法注入，Setter方法注入，注解注入。 构造方法注入： 1234567891011public class User &#123; private String name; private Integer age; private Address address; public User(String name, Integer age, Address address) &#123; this.name = name; this.age = age; this.address = address; &#125;&#125; 12345&lt;bean id = &quot;user&quot; class=&quot;com.andrew.study.domain.User&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;Andrew&quot; /&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;24&quot; /&gt; &lt;constructor-arg name=&quot;address&quot; ref=&quot;address&quot; /&gt;&lt;/bean&gt; setter注入： 12345678910111213141516171819202122232425public class User &#123; private String name; private Integer age; private Address address; public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public Integer getAge() &#123; return age; &#125;&#125; 12345&lt;bean id = &quot;user&quot; class=&quot;com.andrew.study.domain.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Andrew&quot; /&gt; &lt;property name=&quot;age&quot; value=&quot;24&quot; /&gt; &lt;property name=&quot;address&quot; value=&quot;address&quot; /&gt;&lt;/bean&gt; 注解注入： 123456789101112@Componentpublic class User &#123; @Value(&quot;Andrew&quot;) private String name; @Value(&quot;24&quot;) private Integer age; @Autowired private Address address;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://andrew9980.github.io/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://andrew9980.github.io/tags/Spring/"},{"name":"源码","slug":"源码","permalink":"http://andrew9980.github.io/tags/%E6%BA%90%E7%A0%81/"}]}],"categories":[{"name":"RocketMQ","slug":"RocketMQ","permalink":"http://andrew9980.github.io/categories/RocketMQ/"},{"name":"Spring","slug":"Spring","permalink":"http://andrew9980.github.io/categories/Spring/"}],"tags":[{"name":"线上问题","slug":"线上问题","permalink":"http://andrew9980.github.io/tags/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"RocketMQ","slug":"RocketMQ","permalink":"http://andrew9980.github.io/tags/RocketMQ/"},{"name":"Spring","slug":"Spring","permalink":"http://andrew9980.github.io/tags/Spring/"},{"name":"源码","slug":"源码","permalink":"http://andrew9980.github.io/tags/%E6%BA%90%E7%A0%81/"}]}