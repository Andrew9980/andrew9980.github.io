{"meta":{"title":"安德鲁的时光机","subtitle":"不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之","description":"","author":"Andrew","url":"http://example.com","root":"/"},"pages":[{"title":"标签","date":"2022-01-05T08:27:21.829Z","updated":"2022-01-05T07:17:33.885Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2022-01-05T07:17:33.876Z","updated":"2022-01-05T07:17:33.876Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"分类","date":"2022-01-05T08:26:30.372Z","updated":"2022-01-05T08:26:30.372Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-01-05T08:14:53.711Z","updated":"2022-01-05T08:14:53.711Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":"友情链接"},{"title":"关于","date":"2022-01-05T07:17:33.880Z","updated":"2022-01-05T07:17:33.880Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"Repositories","date":"2022-01-05T07:17:33.884Z","updated":"2022-01-05T07:17:33.884Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-01-05T07:17:33.881Z","updated":"2022-01-05T07:17:33.881Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""}],"posts":[{"title":"4-Spring源码解析-Bean实例化流程","slug":"4-Spring源码解析-Bean实例化流程","date":"2022-01-05T09:27:52.000Z","updated":"2022-01-05T09:32:18.809Z","comments":true,"path":"2022/01/05/4-Spring源码解析-Bean实例化流程/","link":"","permalink":"http://example.com/2022/01/05/4-Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%B5%81%E7%A8%8B/","excerpt":"","text":"回顾一下前面的代码，我们分析了Spring是如何解析xml及注册BeanDefinition到BeanFactory，接下来我们从Spring中获取我们的bean。贴一下前面的代码。 12345678public static void main(String[] args) throws IOException &#123; DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); XmlBeanDefinitionReader definitionReader = new XmlBeanDefinitionReader(beanFactory); ClassPathResource resource = new ClassPathResource(&quot;application.xml&quot;); definitionReader.loadBeanDefinitions(resource); Object user = beanFactory.getBean(&quot;user&quot;); System.out.println(user.toString());&#125; 我们进入DefaultListableBeanFactory#getBean方法看看。 123public Object getBean(String name) throws BeansException &#123; return doGetBean(name, null, null, false);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167protected &lt;T&gt; T doGetBean( String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException &#123; // 转换factoryBean的name或者aliasName成为真正beanName String beanName = transformedBeanName(name); Object beanInstance; // 检查手动创建的单例缓存 Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) &#123; if (logger.isTraceEnabled()) &#123; if (isSingletonCurrentlyInCreation(beanName)) &#123; logger.trace(&quot;Returning eagerly cached instance of singleton bean &#x27;&quot; + beanName + &quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;); &#125; else &#123; logger.trace(&quot;Returning cached instance of singleton bean &#x27;&quot; + beanName + &quot;&#x27;&quot;); &#125; &#125; // 有可能getSingleton()获取的bean是最原始的bean，此方法则获取最终的bean实例 beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; // 如果当前bean不是singleton并且正在创建则报错 // 只能处理单例bean的循环依赖问题 if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; // Check if bean definition exists in this factory. // 检查是否有父BeanFactory BeanFactory parentBeanFactory = getParentBeanFactory(); // 如果父BeanFactory存在并且beanDefinitionMap不存在 if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; // Not found -&gt; check parent. // 获取原始beanName String nameToLookup = originalBeanName(name); // 如果父BeanFactory是AbstractBeanFactory则委托AbstractBeanFactory创建对象 if (parentBeanFactory instanceof AbstractBeanFactory) &#123; return ((AbstractBeanFactory) parentBeanFactory).doGetBean( nameToLookup, requiredType, args, typeCheckOnly); &#125; else if (args != null) &#123; // 委托有参构造 return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else if (requiredType != null) &#123; // No args -&gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; else &#123; // return (T) parentBeanFactory.getBean(nameToLookup); &#125; &#125; if (!typeCheckOnly) &#123; markBeanAsCreated(beanName); &#125; StartupStep beanCreation = this.applicationStartup.start(&quot;spring.beans.instantiate&quot;) .tag(&quot;beanName&quot;, name); try &#123; if (requiredType != null) &#123; beanCreation.tag(&quot;beanType&quot;, requiredType::toString); &#125; // 从容器中获取GenericBeanDefinition，并转换为RootBeanDefinition RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // Guarantee initialization of beans that the current bean depends on. // 处理当前bean的依赖bean String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) &#123; for (String dep : dependsOn) &#123; if (isDependent(beanName, dep)) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Circular depends-on relationship between &#x27;&quot; + beanName + &quot;&#x27; and &#x27;&quot; + dep + &quot;&#x27;&quot;); &#125; // 注册依赖的bean registerDependentBean(dep, beanName); try &#123; // 实例化依赖的bean getBean(dep); &#125; catch (NoSuchBeanDefinitionException ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;&#x27;&quot; + beanName + &quot;&#x27; depends on missing bean &#x27;&quot; + dep + &quot;&#x27;&quot;, ex); &#125; &#125; &#125; // Create bean instance. 实例化依赖的bean后，创建指定name的bean实例 if (mbd.isSingleton()) &#123; // 调用getSingleton方法，先查询singletonObjects缓存中的对象，如果没有查到则调用createBean方法 sharedInstance = getSingleton(beanName, () -&gt; &#123; try &#123; return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. // 为了解决循环依赖问题，可能已经被实例化了，所以报错，在这里删除bean destroySingleton(beanName); throw ex; &#125; &#125;); // 处理bean是否是FactoryBean情况 beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; else if (mbd.isPrototype()) &#123; // It&#x27;s a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; // 前置处理 beforePrototypeCreation(beanName); // 创建bean prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; // 后置处理 afterPrototypeCreation(beanName); &#125; // 从bean实例中获取对象 beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125; else &#123; String scopeName = mbd.getScope(); if (!StringUtils.hasLength(scopeName)) &#123; throw new IllegalStateException(&quot;No scope name defined for bean ´&quot; + beanName + &quot;&#x27;&quot;); &#125; Scope scope = this.scopes.get(scopeName); if (scope == null) &#123; throw new IllegalStateException(&quot;No Scope registered for scope name &#x27;&quot; + scopeName + &quot;&#x27;&quot;); &#125; try &#123; Object scopedInstance = scope.get(beanName, () -&gt; &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125;); beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; catch (IllegalStateException ex) &#123; throw new ScopeNotActiveException(beanName, scopeName, ex); &#125; &#125; &#125; catch (BeansException ex) &#123; beanCreation.tag(&quot;exception&quot;, ex.getClass().toString()); beanCreation.tag(&quot;message&quot;, String.valueOf(ex.getMessage())); cleanupAfterBeanCreationFailure(beanName); throw ex; &#125; finally &#123; beanCreation.end(); &#125; &#125; return adaptBeanInstance(name, beanInstance, requiredType);&#125; 先调用transformedBeanName方法，将beanName转化一下，主要是去掉&amp;（factoryName）或者基于alias找到匹配的beanName。然后调用getSingleton从缓存中查，逻辑如下。 123456789101112131415161718192021222324252627282930313233343536public Object getSingleton(String beanName) &#123; return getSingleton(beanName, true);&#125;protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123; // Quick check for existing instance without full singleton lock // 从已经实例化过的单例bean缓存中查询（一级缓存） Object singletonObject = this.singletonObjects.get(beanName); // 如果一级缓存查不到则判断 bean 是否被正在创建 if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123; // 从二级缓存查找 singletonObject = this.earlySingletonObjects.get(beanName); // 如果二级缓存查不到并且允许提前创建 if (singletonObject == null &amp;&amp; allowEarlyReference) &#123; synchronized (this.singletonObjects) &#123; // Consistent creation of early reference within full singleton lock // 再次从一级/二级缓存获取 singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) &#123; singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null) &#123; // 从objectFactory中获取，如果存在objectFactory则直接获取对象 ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) &#123; singletonObject = singletonFactory.getObject(); // 从三级缓存中拿到对象后放入二级缓存 this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); &#125; &#125; &#125; &#125; &#125; &#125; return singletonObject;&#125; 具体的逻辑注释中已经写明了，下面说一下一级，二级，三级缓存是什么。 Map&lt;String, Object&gt; singletonObjects：一级缓存，主要存储已经实例化的Bean对象 Map&lt;String, Object&gt; earlySingletonObjects：二级缓存，主要存储提前暴露的Bean对象 Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories：三级缓存，主要存储用户创建对象的ObjectFactory 我们继续往下走，当从缓存中都拿不到对象时，判断当前beanName是否是单例，并且正在被创建，如果是则报错，否则获取是否有parentBeanFactory，如果没有则标记当前beanName标记为正在被创建。 123456789101112protected void markBeanAsCreated(String beanName) &#123; if (!this.alreadyCreated.contains(beanName)) &#123; synchronized (this.mergedBeanDefinitions) &#123; if (!this.alreadyCreated.contains(beanName)) &#123; // Let the bean definition get re-merged now that we&#x27;re actually creating // the bean... just in case some of its metadata changed in the meantime. clearMergedBeanDefinition(beanName); this.alreadyCreated.add(beanName); &#125; &#125; &#125;&#125; 然后调用getMergedLocalBeanDefinition获取标准BeanDefinition，我们进去看看具体逻辑。 123456789protected RootBeanDefinition getMergedLocalBeanDefinition(String beanName) throws BeansException &#123; // Quick check on the concurrent map first, with minimal locking. RootBeanDefinition mbd = this.mergedBeanDefinitions.get(beanName); // 判断已经合并的beanDefinition并且不需要再合并则直接返回 if (mbd != null &amp;&amp; !mbd.stale) &#123; return mbd; &#125; return getMergedBeanDefinition(beanName, getBeanDefinition(beanName));&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879protected RootBeanDefinition getMergedBeanDefinition( String beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd) throws BeanDefinitionStoreException &#123; synchronized (this.mergedBeanDefinitions) &#123; RootBeanDefinition mbd = null; RootBeanDefinition previous = null; // Check with full lock now in order to enforce the same merged instance. // 如果是顶层bean直接从mergedBeanDefinitions获取返回 if (containingBd == null) &#123; mbd = this.mergedBeanDefinitions.get(beanName); &#125; // 如果获取不到，或者需要再次合并 if (mbd == null || mbd.stale) &#123; previous = mbd; if (bd.getParentName() == null) &#123; // Use copy of given root bean definition. if (bd instanceof RootBeanDefinition) &#123; // mbd = ((RootBeanDefinition) bd).cloneBeanDefinition(); &#125; else &#123; mbd = new RootBeanDefinition(bd); &#125; &#125; else &#123; // Child bean definition: needs to be merged with parent. BeanDefinition pbd; try &#123; String parentBeanName = transformedBeanName(bd.getParentName()); if (!beanName.equals(parentBeanName)) &#123; pbd = getMergedBeanDefinition(parentBeanName); &#125; else &#123; BeanFactory parent = getParentBeanFactory(); if (parent instanceof ConfigurableBeanFactory) &#123; pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName); &#125; else &#123; throw new NoSuchBeanDefinitionException(parentBeanName, &quot;Parent name &#x27;&quot; + parentBeanName + &quot;&#x27; is equal to bean name &#x27;&quot; + beanName + &quot;&#x27;: cannot be resolved without a ConfigurableBeanFactory parent&quot;); &#125; &#125; &#125; catch (NoSuchBeanDefinitionException ex) &#123; throw new BeanDefinitionStoreException(bd.getResourceDescription(), beanName, &quot;Could not resolve parent bean definition &#x27;&quot; + bd.getParentName() + &quot;&#x27;&quot;, ex); &#125; // Deep copy with overridden values. mbd = new RootBeanDefinition(pbd); mbd.overrideFrom(bd); &#125; // Set default singleton scope, if not configured before. if (!StringUtils.hasLength(mbd.getScope())) &#123; mbd.setScope(SCOPE_SINGLETON); &#125; // A bean contained in a non-singleton bean cannot be a singleton itself. // Let&#x27;s correct this on the fly here, since this might be the result of // parent-child merging for the outer bean, in which case the original inner bean // definition will not have inherited the merged outer bean&#x27;s singleton status. if (containingBd != null &amp;&amp; !containingBd.isSingleton() &amp;&amp; mbd.isSingleton()) &#123; mbd.setScope(containingBd.getScope()); &#125; // Cache the merged bean definition for the time being // (it might still get re-merged later on in order to pick up metadata changes) if (containingBd == null &amp;&amp; isCacheBeanMetadata()) &#123; this.mergedBeanDefinitions.put(beanName, mbd); &#125; &#125; if (previous != null) &#123; copyRelevantMergedBeanDefinitionCaches(previous, mbd); &#125; return mbd; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"源码","slug":"源码","permalink":"http://example.com/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"3-Spring源码解析-Bean加载流程","slug":"3-Spring源码解析-Bean加载流程","date":"2022-01-05T09:18:32.000Z","updated":"2022-01-05T09:27:26.843Z","comments":true,"path":"2022/01/05/3-Spring源码解析-Bean加载流程/","link":"","permalink":"http://example.com/2022/01/05/3-Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Bean%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/","excerpt":"","text":"了解Spring的资源加载原理后，我们就可以分析Spring是如何解析xml加载bean了，我们首先创建User类 1234567891011121314151617public class User &#123; private String name; private Integer age; public void setAge(Integer age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public Integer getAge() &#123; return age; &#125;&#125; 然后在resource下创建一个application.xml 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;address&quot; class=&quot;com.andrew.study.domain.Address&quot;&gt; &lt;property name=&quot;province&quot; value=&quot;湖北&quot; /&gt; &lt;property name=&quot;city&quot; value=&quot;武汉&quot; /&gt; &lt;/bean&gt; &lt;bean id = &quot;user&quot; class=&quot;com.andrew.study.domain.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Andrew&quot; /&gt; &lt;property name=&quot;age&quot; value=&quot;24&quot; /&gt; &lt;property name=&quot;address&quot; value=&quot;address&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 测试代码： 12345678public static void main(String[] args) throws IOException &#123; DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); XmlBeanDefinitionReader definitionReader = new XmlBeanDefinitionReader(beanFactory); ClassPathResource resource = new ClassPathResource(&quot;application.xml&quot;); definitionReader.loadBeanDefinitions(resource); Object user = beanFactory.getBean(&quot;user&quot;); System.out.println(user.toString());&#125; 流程： 创建出Spring容器beanFactory 创建xml读取器并注册beanFactory 创建文件资源ClasspathResource 读取器加载文件资源注册到Spring容器中 从Spring容器获取name=user的bean 打印bean 一、创建BeanFactory首先从获取beanFactory分析 看一下结构图： BeanFactory作为Spring容器，提供了一系列获取Bean的方法，HierarchicalBeanFactory继承并强化了，提供了获取parentBeanFactory方法，ConfigurableBeanFactory则是提供了配置BeanFactory的一系列方法,AutowireCapableBeanFactory直接继承BeanFactory，提供了自动注入功能，并且提前暴露已经存在的bean实例。ListableBeanFactory用于枚举出BeanFactory中所有的Bean，而不用BeanFactory获取Bean要一个一个的getBean，ConfigurableListableBeanFactory同时继承了ListableBeanFactory，ConfigurableBeanFactory，AutowireCapatableBeanFactory，提供分析和修改Bean和预实例化Bean的功能。xxxRegister接口和类提供了对Bean的注册功能，DefaultListableeBeanFactory继承并实现了ConfigurableListableBeanFactory和AbstractAutowireCapatableBeanFactory以及BeanDefinitionRegister，相当于BeanFactory系列功能集大成者，所以我们通过此类来创建出我们的BeanFactory。 二、Xml加载及解析XmlBeanDefinitionReader用于将xml配置文件加载并注册成BeanDefinition，不过我们先创建出对象，在构造方法中传入我们的BeanDefinitionRegister对象。因为DefaultListableeBeanFactory作为BeanDefinitionRegister实现类，因此可以把它传入。 123public XmlBeanDefinitionReader(BeanDefinitionRegistry registry) &#123; super(registry);&#125; 我们进入super方法，因为XmlBeanDefinitionReader继承了AbstractBeanDefinitionReader，我们看看他的构造方法. 1234567891011121314151617181920protected AbstractBeanDefinitionReader(BeanDefinitionRegistry registry) &#123; Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;); this.registry = registry; // Determine ResourceLoader to use. if (this.registry instanceof ResourceLoader) &#123; this.resourceLoader = (ResourceLoader) this.registry; &#125; else &#123; this.resourceLoader = new PathMatchingResourcePatternResolver(); &#125; // Inherit Environment if possible if (this.registry instanceof EnvironmentCapable) &#123; this.environment = ((EnvironmentCapable) this.registry).getEnvironment(); &#125; else &#123; this.environment = new StandardEnvironment(); &#125;&#125; 首先判断传入的regiser是否是ResourceLoader，如果是可以直接使用当前的resourceLoader，不是则使用PathMatchimingResourcePatternResolver用来加载文件，关于ResourceLoader不清楚，可以看上一讲。之后ResourceLoader后再来指定当前的环境，先判断registry是否是EnvironmentCapable，不是则按照标准环境策略加载。 Environment用来指定当前的Spring容器运行在什么样的环境中，我们配置的spring.profiles.active=dev就是用来指定当前的Spring基于哪个配置文件来加载。 配置好BeanFactory和ResourceLoader后，我用来指定加载资源，并执行加载，将配置文件中的转为BeanDefinition 12ClassPathResource resource = new ClassPathResource(&quot;application.xml&quot;);definitionReader.loadBeanDefinitions(resource); 看一下loadBeanDefinitions(resource)如何实现的。 1234567891011121314151617181920212223242526272829303132333435public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123; return loadBeanDefinitions(new EncodedResource(resource));&#125;public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123; Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;); if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Loading XML bean definitions from &quot; + encodedResource); &#125; Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (!currentResources.add(encodedResource)) &#123; throw new BeanDefinitionStoreException( &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;); &#125; try (InputStream inputStream = encodedResource.getResource().getInputStream()) &#123; InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) &#123; inputSource.setEncoding(encodedResource.getEncoding()); &#125; return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException( &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex); &#125; finally &#123; currentResources.remove(encodedResource); if (currentResources.isEmpty()) &#123; this.resourcesCurrentlyBeingLoaded.remove(); &#125; &#125;&#125; 首先将我们的Resource进行编码，避免乱码。首先是获取正在加载的Resource，从encodedResource中获取InputStream，然后进入doLoadBeanDefinitions。 1234567891011121314151617181920212223242526272829303132333435protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException &#123; try &#123; Document doc = doLoadDocument(inputSource, resource); int count = registerBeanDefinitions(doc, resource); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Loaded &quot; + count + &quot; bean definitions from &quot; + resource); &#125; return count; &#125; catch (BeanDefinitionStoreException ex) &#123; throw ex; &#125; catch (SAXParseException ex) &#123; throw new XmlBeanDefinitionStoreException(resource.getDescription(), &quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex); &#125; catch (SAXException ex) &#123; throw new XmlBeanDefinitionStoreException(resource.getDescription(), &quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex); &#125; catch (ParserConfigurationException ex) &#123; throw new BeanDefinitionStoreException(resource.getDescription(), &quot;Parser configuration exception parsing XML from &quot; + resource, ex); &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException(resource.getDescription(), &quot;IOException parsing XML document from &quot; + resource, ex); &#125; catch (Throwable ex) &#123; throw new BeanDefinitionStoreException(resource.getDescription(), &quot;Unexpected exception parsing XML document from &quot; + resource, ex); &#125;&#125; 进入doLoadDocument 1234567891011protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception &#123; /** * inputSource：document资源 * getEntityResolver()得到entityResolver用于文档的验证 * errorHandler：sax的error处理器 * getValidationModeForResource(resource) xml文档的验证模式，默认模式是自动，XmlValidationModeDetector.VALIDATION_AUTO * namespaceAware 表示是否开启自动感知名称空间 */ return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler, getValidationModeForResource(resource), isNamespaceAware());&#125; 上面注释很清楚了，就是将当前文件资源解析成Document对象便于后面的解析。我们进入registerBeanDefinitions方法。 123456public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123; BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); int countBefore = getRegistry().getBeanDefinitionCount(); documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore;&#125; 首先创建BeanDefinitionDocumentReader对象，然后获取当前容器中存在的BeanDefinition数量。我们进入registerBeanDefinitions方法 123456789101112131415161718192021222324252627282930313233343536public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123; this.readerContext = readerContext; // doc.getDocumentElement() -&gt; CoreDocumentImpl#getDocumentElement() doRegisterBeanDefinitions(doc.getDocumentElement());&#125;protected void doRegisterBeanDefinitions(Element root) &#123; BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) &#123; String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) &#123; String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); // We cannot use Profiles.of(...) since profile expressions are not supported // in XML config. See SPR-12458 for details. if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec + &quot;] not matching: &quot; + getReaderContext().getResource()); &#125; return; &#125; &#125; &#125; // 前置处理xml标签的数据 preProcessXml(root); // 处理import alias bean 标签 parseBeanDefinitions(root, this.delegate); // 后置处理xml标签的数据 postProcessXml(root); this.delegate = parent;&#125; 我们主要看parseBeanDefinitions方法 1234567891011121314151617181920protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; if (delegate.isDefaultNamespace(root)) &#123; NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (node instanceof Element) &#123; Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) &#123; parseDefaultElement(ele, delegate); &#125; else &#123; delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; delegate.parseCustomElement(root); &#125;&#125; 这里就是拿到Document的Element然后遍历Element下面的Node，我们写的标签,就相当于一个Node，解析方法在parseDefaultElement中。 123456789101112131415private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123; if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; importBeanDefinitionResource(ele); &#125; else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; processAliasRegistration(ele); &#125; else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; processBeanDefinition(ele, delegate); &#125; else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123; // recurse doRegisterBeanDefinitions(ele); &#125;&#125; 这里我们就能看到处理了, , , 标签，我们这里只分析,其他的大同小异, 进入processBeanDefinition方法。 12345678910111213141516protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123; BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) &#123; bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try &#123; // Register the final decorated instance. BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); &#125; catch (BeanDefinitionStoreException ex) &#123; getReaderContext().error(&quot;Failed to register bean definition with name &#x27;&quot; + bdHolder.getBeanName() + &quot;&#x27;&quot;, ele, ex); &#125; // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); &#125;&#125; 这里首先就是根据element来解析，调用parseBeanDefinitionElement 123public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) &#123; return parseBeanDefinitionElement(ele, null);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) &#123; //&lt;bean&gt; 的id和name属性值 String id = ele.getAttribute(ID_ATTRIBUTE); String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); List&lt;String&gt; aliases = new ArrayList&lt;&gt;(); if (StringUtils.hasLength(nameAttr)) &#123; String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); &#125; String beanName = id; if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123; beanName = aliases.remove(0); if (logger.isTraceEnabled()) &#123; logger.trace(&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot; + beanName + &quot;&#x27; as bean name and &quot; + aliases + &quot; as aliases&quot;); &#125; &#125; if (containingBean == null) &#123; checkNameUniqueness(beanName, aliases, ele); &#125; // 解析&lt;bean&gt; AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); if (beanDefinition != null) &#123; if (!StringUtils.hasText(beanName)) &#123; try &#123; if (containingBean != null) &#123; beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); &#125; else &#123; beanName = this.readerContext.generateBeanName(beanDefinition); // Register an alias for the plain bean class name, if still possible, // if the generator returned the class name plus a suffix. // This is expected for Spring 1.2/2.0 backwards compatibility. String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123; aliases.add(beanClassName); &#125; &#125; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot; + &quot;using generated bean name [&quot; + beanName + &quot;]&quot;); &#125; &#125; catch (Exception ex) &#123; error(ex.getMessage(), ele); return null; &#125; &#125; String[] aliasesArray = StringUtils.toStringArray(aliases); return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); &#125; return null;&#125; 接下来就是从element中获取值了，然后检查beanName和alias是否唯一处理，接着将bean标签注册成一个AbstractBeanDefinition。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, @Nullable BeanDefinition containingBean) &#123; this.parseState.push(new BeanEntry(beanName)); String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123; className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); &#125; String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123; parent = ele.getAttribute(PARENT_ATTRIBUTE); &#125; try &#123; AbstractBeanDefinition bd = createBeanDefinition(className, parent); // 给定className创建一个BeanDefinition // 给beanDefinition属性赋值 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); // &lt;meta&gt; 标签赋值 parseMetaElements(ele, bd); parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); // &lt;constructor-arg&gt; 解析 parseConstructorArgElements(ele, bd); // &lt;property&gt; 解析 parsePropertyElements(ele, bd); // &lt;qualifier&gt; 解析 parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; &#125; catch (ClassNotFoundException ex) &#123; error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex); &#125; catch (NoClassDefFoundError err) &#123; error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err); &#125; catch (Throwable ex) &#123; error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex); &#125; finally &#123; this.parseState.pop(); &#125; return null;&#125; 首先标识当前beanName正在被解析，然后获取class和parent属性，根据className创建一个GenericBeanDefinition 12345678910111213141516171819202122protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName) throws ClassNotFoundException &#123; return BeanDefinitionReaderUtils.createBeanDefinition( parentName, className, this.readerContext.getBeanClassLoader());&#125;public static AbstractBeanDefinition createBeanDefinition( @Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader) throws ClassNotFoundException &#123; GenericBeanDefinition bd = new GenericBeanDefinition(); bd.setParentName(parentName); if (className != null) &#123; if (classLoader != null) &#123; bd.setBeanClass(ClassUtils.forName(className, classLoader)); &#125; else &#123; bd.setBeanClassName(className); &#125; &#125; return bd;&#125; GenericBeanDefinition是一个标准的BeanDefinition，里面定义了许多有关Bean的属性并有默认值。我们得到标准BeanDefinition后，解析的其他属性，singleton，scop，abstract等等，解析方法在parseBeanDefinitionAttributes中。然后解析的内部标签，,, ,，代码比较简单就不列出了。解析完毕后将我们得到的BeanDefinition返回，然后将当前bean的解析状态删除。 后面根据bean是否有父类和是否是FactoryBean初始化一下beanName，最后根据beanDefintion，beanName，beanClassName创建BeanDefinitionHolder返回。 BeanDefinitionHolder是BeanDefinition的持有类，拥有beanName和alias属性，可以作为占位符注册一个内部bean。 拿到BeanDefinitionHolder后，bean是否需要装饰，最后将bean在BeanFactory中注册。我们开始分析注册方法registerBeanDefinition 12345678910111213141516public static void registerBeanDefinition( BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException &#123; // Register bean definition under primary name. String beanName = definitionHolder.getBeanName(); registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); // Register aliases for bean name, if any. String[] aliases = definitionHolder.getAliases(); if (aliases != null) &#123; for (String alias : aliases) &#123; registry.registerAlias(beanName, alias); &#125; &#125;&#125; 首先从BeanDefinitionHolder中获取beanName，然后注册到BeanFactory中，最后将beanName和alias映射，我们详细看一下bean的注册逻辑。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException &#123; Assert.hasText(beanName, &quot;Bean name must not be empty&quot;); Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;); if (beanDefinition instanceof AbstractBeanDefinition) &#123; try &#123; ((AbstractBeanDefinition) beanDefinition).validate(); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, &quot;Validation of bean definition failed&quot;, ex); &#125; &#125; BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName); if (existingDefinition != null) &#123; if (!isAllowBeanDefinitionOverriding()) &#123; throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition); &#125; else if (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123; // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE if (logger.isInfoEnabled()) &#123; logger.info(&quot;Overriding user-defined bean definition for bean &#x27;&quot; + beanName + &quot;&#x27; with a framework-generated bean definition: replacing [&quot; + existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;); &#125; &#125; else if (!beanDefinition.equals(existingDefinition)) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Overriding bean definition for bean &#x27;&quot; + beanName + &quot;&#x27; with a different definition: replacing [&quot; + existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;); &#125; &#125; else &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Overriding bean definition for bean &#x27;&quot; + beanName + &quot;&#x27; with an equivalent definition: replacing [&quot; + existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;); &#125; &#125; this.beanDefinitionMap.put(beanName, beanDefinition); &#125; else &#123; if (hasBeanCreationStarted()) &#123; // Cannot modify startup-time collection elements anymore (for stable iteration) synchronized (this.beanDefinitionMap) &#123; this.beanDefinitionMap.put(beanName, beanDefinition); List&lt;String&gt; updatedDefinitions = new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; removeManualSingletonName(beanName); &#125; &#125; else &#123; // Still in startup registration phase this.beanDefinitionMap.put(beanName, beanDefinition); this.beanDefinitionNames.add(beanName); removeManualSingletonName(beanName); &#125; this.frozenBeanDefinitionNames = null; &#125; if (existingDefinition != null || containsSingleton(beanName)) &#123; resetBeanDefinition(beanName); &#125; else if (isConfigurationFrozen()) &#123; clearByTypeCache(); &#125;&#125; 首先判断BeanDefinition是否是AbstractBeanDefinition类型，如果是，则进行校验。然后从beanDefinitionMap（存储已经注册完成的Bean）中查找当前的beanName是否已经注册，如果存在则判断当前容器是否允许相同beanName的beanDefinition覆盖，判断优先级，判断两个BeanDefinition是否相同，最后将BeanDefinition放入到beanDefinitionMap中。如果不存在，判断bean是否正在被创建，然后直接将bean放入到beanDefinitionMap中，然后手动删除正在注册的beanName，manualSingletonNames中存储的是手动注册创建的单例bean。最后如果有存在的Bean则将bean的缓存重置，并在上下文发送注册完成事件。 最后我们回顾一下registerBeanDefinitions方法，注册完成后，重新获取BeanDefinitionMap的size，减去之前的BeanDefinition数量，返回此次注册BeanDefinition的数量。 123456public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123; BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); int countBefore = getRegistry().getBeanDefinitionCount(); documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore;&#125; 至此，我们Bean的加载分析完毕，下面开始总结。 总结 我们常说的Spring的Bean其实是一个BeanDefinition对象，BeanDefinition对象用来描述我们的Bean，包括我们熟知的一些属性，beanName，className，scope，autowireType等等。 Spring容器内部维持了一个BeanDefinitionMap，当我们注册后，可以直接从BeanDefinitionMap中获取BeanDefinition，不用重复解析xml文档提升效率。 可以看见，Spring解析xml其实用到的就是我们熟知的一些技术，Spring并不可怕，持之以恒。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"源码","slug":"源码","permalink":"http://example.com/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"2.Spring源码解析-统一资源管理","slug":"2-Spring源码解析-统一资源管理","date":"2022-01-05T09:00:00.000Z","updated":"2022-01-05T09:17:19.854Z","comments":true,"path":"2022/01/05/2-Spring源码解析-统一资源管理/","link":"","permalink":"http://example.com/2022/01/05/2-Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/","excerpt":"","text":"了解了Spring IOC的概念后，由于Spring容器需要从配置文件中读取bean，所以我们从Spring文件资源加载开始，首先了解Spring的文件资源是什么样子的。 ![](D:/blogs/gitee/source/_posts/2-Spring源码解析-统一资源管理/Spring Resource Class.png) Spring将文件资源抽象成两种，分别是文件描述和文件加载，对应接口为Resource和ResourceLoader Resource接口： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public interface Resource extends InputStreamSource &#123; /** 判断resource在物理路径下是否存在 */ boolean exists(); /** 文件是否可读，需要首选判断文件是否存在 */ default boolean isReadable() &#123; return exists(); &#125; /** 判断文件是否被打开，如果为true，则inputStream不能多次读取，并且读取完后需要close，避免文件泄漏 */ default boolean isOpen() &#123; return false; &#125; /** 判断在文件系统中resource是否是一个文件，getFile可以获取这个文件 */ default boolean isFile() &#123; return false; &#125; /** 返回当前resource的URL，如果不能用url表示，则报错 */ URL getURL() throws IOException; /** 返回当前resource的URI，如果不能用uri表示，则报错 */ URI getURI() throws IOException; /** 返回Resource代表的file */ File getFile() throws IOException; /** 返回ReadableByteChannel */ default ReadableByteChannel readableChannel() throws IOException &#123; return Channels.newChannel(getInputStream()); &#125; /** 返回文件内容长度 */ long contentLength() throws IOException; /** 返回文件最后修改的时间戳 */ long lastModified() throws IOException; /** 创建相对路径下的resource */ Resource createRelative(String relativePath) throws IOException; /** 文件名 */ @Nullable String getFilename(); /** 文件描述 */ String getDescription();&#125; Resource接口抽象了一系列关于描述文件的方法，其实现类或子接口提供了不同的功能。 WritableResource 增加可写功能 ContextResource 增加上下文功能，可以读取ServletContextResource资源 UrlResource 支持URL和File方式访问 FileUrlResource UrlResource实现类，支持file方式访问 FileSystemResource WritableResource实现类，同时支持url和file方式访问 ClassPathResource classpath路径访问文件 ByteArrayResource 字节数组资源访问 InputStreamResource inputStream访问 ResourceUtils定义了可能访问到的文件类型。 1234567891011121314151617181920212223242526272829303132333435363738394041public abstract class ResourceUtils &#123;/** Pseudo URL prefix for loading from the class path: &quot;classpath:&quot;. */public static final String CLASSPATH_URL_PREFIX = &quot;classpath:&quot;;/** URL prefix for loading from the file system: &quot;file:&quot;. */public static final String FILE_URL_PREFIX = &quot;file:&quot;;/** URL prefix for loading from a jar file: &quot;jar:&quot;. */public static final String JAR_URL_PREFIX = &quot;jar:&quot;;/** URL prefix for loading from a war file on Tomcat: &quot;war:&quot;. */public static final String WAR_URL_PREFIX = &quot;war:&quot;;/** URL protocol for a file in the file system: &quot;file&quot;. */public static final String URL_PROTOCOL_FILE = &quot;file&quot;;/** URL protocol for an entry from a jar file: &quot;jar&quot;. */public static final String URL_PROTOCOL_JAR = &quot;jar&quot;;/** URL protocol for an entry from a war file: &quot;war&quot;. */public static final String URL_PROTOCOL_WAR = &quot;war&quot;;/** URL protocol for an entry from a zip file: &quot;zip&quot;. */public static final String URL_PROTOCOL_ZIP = &quot;zip&quot;;/** URL protocol for an entry from a WebSphere jar file: &quot;wsjar&quot;. */public static final String URL_PROTOCOL_WSJAR = &quot;wsjar&quot;;/** URL protocol for an entry from a JBoss jar file: &quot;vfszip&quot;. */public static final String URL_PROTOCOL_VFSZIP = &quot;vfszip&quot;;/** URL protocol for a JBoss file system resource: &quot;vfsfile&quot;. */public static final String URL_PROTOCOL_VFSFILE = &quot;vfsfile&quot;;/** URL protocol for a general JBoss VFS resource: &quot;vfs&quot;. */public static final String URL_PROTOCOL_VFS = &quot;vfs&quot;;/** File extension for a regular jar file: &quot;.jar&quot;. */public static final String JAR_FILE_EXTENSION = &quot;.jar&quot;;&#125; ResourceLoader接口： Spring统一了加载资源策略，用ResourceLoader接口以加载classpath协议(classpath:xxxx.xml)或者file system(file:/xxxx/xxxx/xxx.xml)协议的文件。其中加载文件的核心方法是getResource，通过传入的文件路径，转变成Resource。 12345678910111213public interface ResourceLoader &#123; /** classpath前缀常量 引用 ResourceUtils.CLASSPATH_URL_PREFIX -&gt; &quot;classpath:&quot;*/ String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX; /** 通过给定的location返回resource，不确定是否存在，需要调用exsist */ Resource getResource(String location); /** 获取当前文件的ClassLoader 一般默认为Thread.currentThread() */ @Nullable ClassLoader getClassLoader();&#125; DefaultResourceLoader是ResourceLoader的默认实现，其getResource方法则是核心的文件加载策略。 1234567891011121314151617181920212223242526272829303132// DefaultResourceLoader#getResourcepublic Resource getResource(String location) &#123; Assert.notNull(location, &quot;Location must not be null&quot;); // 自定义协议 for (ProtocolResolver protocolResolver : getProtocolResolvers()) &#123; Resource resource = protocolResolver.resolve(location, this); if (resource != null) &#123; return resource; &#125; &#125; // location是/开头则默认调用ClassPathContextResource if (location.startsWith(&quot;/&quot;)) &#123; return getResourceByPath(location); &#125; // location是classpath:开头 else if (location.startsWith(CLASSPATH_URL_PREFIX)) &#123; return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader()); &#125; else &#123; try &#123; // Try to parse the location as a URL... // url 协议 URL url = new URL(location); return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url)); &#125; catch (MalformedURLException ex) &#123; // No URL -&gt; resolve as resource path. // 不是url协议还是使用ClassPathContextResource return getResourceByPath(location); &#125; &#125;&#125; 首先获取自定义的协议解析器，如果存在则通过实现的resolve方法加载文件。（后文详谈） 1234private final Set&lt;ProtocolResolver&gt; protocolResolvers = new LinkedHashSet&lt;&gt;(4);public Collection&lt;ProtocolResolver&gt; getProtocolResolvers() &#123; return this.protocolResolvers;&#125; 如果没有自定义的协议解析器或者加载不到当前文件的协议，则判断路径是否是/开头，如果是则按照classpath:协议加载并且具有上下文功能 123protected Resource getResourceByPath(String path) &#123; return new ClassPathContextResource(path, getClassLoader());&#125; 然后判断是否是classpath:开头，如果是则按照classpath:协议加载。如果都不是则按照url协议解析，如果不是url协议，则抛出错误，在异常处理中，最后还是按照classpath:协议加载并且具有上下文功能。 其中getResourceByPath为将给的路径转成一个Resource的绑定，默认实现是按照classpath上下文解析，如果文件是file或者web协议则解析出错，因此FileSystemXmlApplicationContext和XmlWebApplicationContext继承了DefaultResourceLoader并覆盖了getResourceByPath实现。 1234567// FileSystemXmlApplicationContext#getResourceByPathprotected Resource getResourceByPath(String path) &#123; if (path.startsWith(&quot;/&quot;)) &#123; path = path.substring(1); &#125; return new FileSystemResource(path);&#125; 123456// XmlWebApplicationContext extends AbstractRefreshableWebApplicationContext// AbstractRefreshableWebApplicationContext#getResourceByPathprotected Resource getResourceByPath(String path) &#123; Assert.state(this.servletContext != null, &quot;No ServletContext available&quot;); return new ServletContextResource(this.servletContext, path);&#125; 前面提到ProtocolResolver接口是提供协议解析，用户可以自定义协议并且实现resovle方法用于解析逻辑。 123456@FunctionalInterfacepublic interface ProtocolResolver &#123; @Nullable Resource resolve(String location, ResourceLoader resourceLoader);&#125; 示例： 1234567DefaultResourceLoader resourceLoader = new DefaultResourceLoader();resourceLoader.addProtocolResolver((location, resourceLoader1) -&gt; &#123; if (!location.startsWith(&quot;path:&quot;)) return null; String substring = location.substring(5); return resourceLoader1.getResource(&quot;classpath:&quot; + substring);&#125;); 由于ProtocolResovler是函数式接口，这里直接调用DefalutResourceLoader的addProtocolResovler方法使用lambda表达式创建一个ProtocolResovler的实现。 这里自定义path:前缀的协议，并将path截取后改为classpath:协议。具体逻辑用户可以根据业务需要自行编写。 由于ResourceLoader接口的getResource只能读取单个文件，当需要批量读取文件时显得不足。因此ResourcePatternResolver 继承ResourceLoader提供了getResources，通过传入的locationPattern参数，使用Ant风格用于匹配多个文件后加载。 Apache Ant风格： ? 同一通配任意单个字符 * 同一通配任意多个字符 ** 通配多个目录下的任意字符 示例： classpath:?.xml 通配classpath路径下x.xml文件 classpath:*.xml 通配classpath路径下以.xml为后缀的文件 com/andrew/**/*.xml 通配以com/andrew开头的文件夹下的所有xml后缀文件 ResourcePatternResolver接口： 12345678public interface ResourcePatternResolver extends ResourceLoader &#123; /** classpath路径通配符常量：classpath*: */ String CLASSPATH_ALL_URL_PREFIX = &quot;classpath*:&quot;; /** 解析给定的路径通配符加载多个文件 */ Resource[] getResources(String locationPattern) throws IOException;&#125; PathMatchingResourcePatternResovler实现ResourcePatterResovler，加载策略代码： 12345678910111213141516171819202122232425262728293031public Resource[] getResources(String locationPattern) throws IOException &#123; Assert.notNull(locationPattern, &quot;Location pattern must not be null&quot;); // 首先判断是否是classpath*:前缀 if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123; // 通过classpath查找 // a class path resource (multiple resources for same name possible) // 判断是否是classpath*:开头 if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123; // a class path resource pattern return findPathMatchingResources(locationPattern); &#125; else &#123; // all class path resources with the given name return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length())); &#125; &#125; else &#123; // 通过file查找 // Generally only look for a pattern after a prefix here, // and on Tomcat only after the &quot;*/&quot; separator for its &quot;war:&quot; protocol. int prefixEnd = (locationPattern.startsWith(&quot;war:&quot;) ? locationPattern.indexOf(&quot;*/&quot;) + 1 : locationPattern.indexOf(&#x27;:&#x27;) + 1); if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123; // a file pattern // 找匹配文件 return findPathMatchingResources(locationPattern); &#125; else &#123; // a single resource with the given name return new Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;; &#125; &#125;&#125; 首先判断是否是classpath*:开头，如果是再截去路径字符串classpath*:剩下的字符串是否符合ant风格，如果是则执行加载策略。 12345678910111213141516171819202122232425262728293031323334protected Resource[] findPathMatchingResources(String locationPattern) throws IOException &#123; // 文件夹最后一个目录 /static/*.xml 则rootDirPath=/static/ classpath*:*.xml rootDirPath=classpath*: String rootDirPath = determineRootDir(locationPattern); // 文件匹配，例如：*.xml String subPattern = locationPattern.substring(rootDirPath.length()); // 给定路径下的文件夹作为单个resource Resource[] rootDirResources = getResources(rootDirPath); Set&lt;Resource&gt; result = new LinkedHashSet&lt;&gt;(16); for (Resource rootDirResource : rootDirResources) &#123; rootDirResource = resolveRootDirResource(rootDirResource); // 当前文件夹在系统下的绝对路径 URL rootDirUrl = rootDirResource.getURL(); if (equinoxResolveMethod != null &amp;&amp; rootDirUrl.getProtocol().startsWith(&quot;bundle&quot;)) &#123; // 判断协议是否是bundle URL resolvedUrl = (URL) ReflectionUtils.invokeMethod(equinoxResolveMethod, null, rootDirUrl); if (resolvedUrl != null) &#123; rootDirUrl = resolvedUrl; &#125; rootDirResource = new UrlResource(rootDirUrl); &#125; if (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) &#123; // 判断协议是否是vfs result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirUrl, subPattern, getPathMatcher())); &#125; else if (ResourceUtils.isJarURL(rootDirUrl) || isJarResource(rootDirResource)) &#123; // 判断协议是否是jar result.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirUrl, subPattern)); &#125; else &#123; result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern)); &#125; &#125; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Resolved location pattern [&quot; + locationPattern + &quot;] to resources &quot; + result); &#125; return result.toArray(new Resource[0]);&#125; 首先找到文件的根目录，如果location是/static/.xml，则rootDirPath是/static/，如果是classpath: 则rootDirPath是classpath*: 如果是classpath*:static/.xml,则rootDirPath是classpath:static/ 1234567891011protected String determineRootDir(String location) &#123; int prefixEnd = location.indexOf(&#x27;:&#x27;) + 1; int rootDirEnd = location.length(); while (rootDirEnd &gt; prefixEnd &amp;&amp; getPathMatcher().isPattern(location.substring(prefixEnd, rootDirEnd))) &#123; rootDirEnd = location.lastIndexOf(&#x27;/&#x27;, rootDirEnd - 2) + 1; &#125; if (rootDirEnd == 0) &#123; rootDirEnd = prefixEnd; &#125; return location.substring(0, rootDirEnd);&#125; 然后截去根目录，得到通配符文件*.xml路径。然后调用getResources获取根目录下的所有文件夹作为Resource数组 12345678910111213141516171819202122232425262728293031public Resource[] getResources(String locationPattern) throws IOException &#123; Assert.notNull(locationPattern, &quot;Location pattern must not be null&quot;); // 首先判断是否是classpath*:前缀 if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123; // 通过classpath查找 // a class path resource (multiple resources for same name possible) // 判断是否是classpath*:开头 if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123; // a class path resource pattern return findPathMatchingResources(locationPattern); &#125; else &#123; // all class path resources with the given name return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length())); &#125; &#125; else &#123; // 通过file查找 // Generally only look for a pattern after a prefix here, // and on Tomcat only after the &quot;*/&quot; separator for its &quot;war:&quot; protocol. int prefixEnd = (locationPattern.startsWith(&quot;war:&quot;) ? locationPattern.indexOf(&quot;*/&quot;) + 1 : locationPattern.indexOf(&#x27;:&#x27;) + 1); if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123; // a file pattern // 找匹配文件 return findPathMatchingResources(locationPattern); &#125; else &#123; // a single resource with the given name return new Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;; &#125; &#125;&#125; 可以发现调用getResources其实是调用的findAllClassPathResources方法，用于将目录转变成Resource，如果是classpath*:.xml则加载类路径下的所有目录，main目录，resource目录，如果是classpath*:config/*.xml，则只有main/config/目录。 123456789101112131415161718192021222324252627protected Resource[] findAllClassPathResources(String location) throws IOException &#123; String path = location; if (path.startsWith(&quot;/&quot;)) &#123; path = path.substring(1); &#125; Set&lt;Resource&gt; result = doFindAllClassPathResources(path); if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Resolved classpath location [&quot; + location + &quot;] to resources &quot; + result); &#125; return result.toArray(new Resource[0]);&#125;protected Set&lt;Resource&gt; doFindAllClassPathResources(String path) throws IOException &#123; Set&lt;Resource&gt; result = new LinkedHashSet&lt;&gt;(16); ClassLoader cl = getClassLoader(); Enumeration&lt;URL&gt; resourceUrls = (cl != null ? cl.getResources(path) : ClassLoader.getSystemResources(path)); while (resourceUrls.hasMoreElements()) &#123; URL url = resourceUrls.nextElement(); result.add(convertClassLoaderURL(url)); &#125; if (!StringUtils.hasLength(path)) &#123; // The above result is likely to be incomplete, i.e. only containing file system references. // We need to have pointers to each of the jar files on the classpath as well... addAllClassLoaderJarRoots(cl, result); &#125; return result;&#125; 得到rootDirResources后，遍历判断各种文件协议bundle，vfs，jar及其他文件。这里只分析其他，接着进入doFindPathMatchingFileResources方法。 1234567891011121314151617181920212223protected Set&lt;Resource&gt; doFindPathMatchingFileResources(Resource rootDirResource, String subPattern) throws IOException &#123; File rootDir; try &#123; // 文件夹resource的绝对路径 rootDir = rootDirResource.getFile().getAbsoluteFile(); &#125; catch (FileNotFoundException ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Cannot search for matching files underneath &quot; + rootDirResource + &quot; in the file system: &quot; + ex.getMessage()); &#125; return Collections.emptySet(); &#125; catch (Exception ex) &#123; if (logger.isInfoEnabled()) &#123; logger.info(&quot;Failed to resolve &quot; + rootDirResource + &quot; in the file system: &quot; + ex); &#125; return Collections.emptySet(); &#125; return doFindMatchingFileSystemResources(rootDir, subPattern);&#125; 拿到当前目录下文件的绝对路径，如果没有文件则报错。然后进入doFindMatchingFileSystemResources 123456789101112protected Set&lt;Resource&gt; doFindMatchingFileSystemResources(File rootDir, String subPattern) throws IOException &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Looking for matching resources in directory tree [&quot; + rootDir.getPath() + &quot;]&quot;); &#125; // 找到文件路径下所有匹配到的文件 Set&lt;File&gt; matchingFiles = retrieveMatchingFiles(rootDir, subPattern); Set&lt;Resource&gt; result = new LinkedHashSet&lt;&gt;(matchingFiles.size()); for (File file : matchingFiles) &#123; result.add(new FileSystemResource(file)); &#125; return result;&#125; 12345678910111213141516171819202122232425262728293031323334protected Set&lt;File&gt; retrieveMatchingFiles(File rootDir, String pattern) throws IOException &#123; if (!rootDir.exists()) &#123; // Silently skip non-existing directories. if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Skipping [&quot; + rootDir.getAbsolutePath() + &quot;] because it does not exist&quot;); &#125; return Collections.emptySet(); &#125; if (!rootDir.isDirectory()) &#123; // Complain louder if it exists but is no directory. if (logger.isInfoEnabled()) &#123; logger.info(&quot;Skipping [&quot; + rootDir.getAbsolutePath() + &quot;] because it does not denote a directory&quot;); &#125; return Collections.emptySet(); &#125; if (!rootDir.canRead()) &#123; if (logger.isInfoEnabled()) &#123; logger.info(&quot;Skipping search for matching files underneath directory [&quot; + rootDir.getAbsolutePath() + &quot;] because the application is not allowed to read the directory&quot;); &#125; return Collections.emptySet(); &#125; String fullPattern = StringUtils.replace(rootDir.getAbsolutePath(), File.separator, &quot;/&quot;); // 如果通配文件没有/开头则加上 if (!pattern.startsWith(&quot;/&quot;)) &#123; fullPattern += &quot;/&quot;; &#125; // 拼接整个文件路径 /Users/andrew/Documents/projects/spring-framework/spring-study/build/resources/main/profile/*.xml fullPattern = fullPattern + StringUtils.replace(pattern, File.separator, &quot;/&quot;); Set&lt;File&gt; result = new LinkedHashSet&lt;&gt;(8); doRetrieveMatchingFiles(fullPattern, rootDir, result); return result;&#125; 主要进行文件夹过滤，和拼接整个文件的路径，然后进入真正执行的方法doRetrieveMatchingFiles 123456789101112131415161718192021222324protected void doRetrieveMatchingFiles(String fullPattern, File dir, Set&lt;File&gt; result) throws IOException &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Searching directory [&quot; + dir.getAbsolutePath() + &quot;] for files matching pattern [&quot; + fullPattern + &quot;]&quot;); &#125; for (File content : listDirectory(dir)) &#123; String currPath = StringUtils.replace(content.getAbsolutePath(), File.separator, &quot;/&quot;); // 判断是否是文件夹 if (content.isDirectory() &amp;&amp; getPathMatcher().matchStart(fullPattern, currPath + &quot;/&quot;)) &#123; if (!content.canRead()) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Skipping subdirectory [&quot; + dir.getAbsolutePath() + &quot;] because the application is not allowed to read the directory&quot;); &#125; &#125; else &#123; doRetrieveMatchingFiles(fullPattern, content, result); &#125; &#125; if (getPathMatcher().match(fullPattern, currPath)) &#123; result.add(content); &#125; &#125;&#125; listDirectory主要是列出当前目录下的所有文件，然后通过递归找出匹配的文件。最后将拿到的文件转成Resource数组。 上面的分析使用classpath*:协议，当我们不使用此前缀时，调用的还是findPathMatchingResources方法，这里再把代码贴出来 12345678910111213141516171819202122232425262728293031public Resource[] getResources(String locationPattern) throws IOException &#123; Assert.notNull(locationPattern, &quot;Location pattern must not be null&quot;); // 首先判断是否是classpath*:前缀 if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123; // 通过classpath查找 // a class path resource (multiple resources for same name possible) // 判断是否是classpath*:开头 if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123; // a class path resource pattern return findPathMatchingResources(locationPattern); &#125; else &#123; // all class path resources with the given name return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length())); &#125; &#125; else &#123; // 通过file查找 // Generally only look for a pattern after a prefix here, // and on Tomcat only after the &quot;*/&quot; separator for its &quot;war:&quot; protocol. int prefixEnd = (locationPattern.startsWith(&quot;war:&quot;) ? locationPattern.indexOf(&quot;*/&quot;) + 1 : locationPattern.indexOf(&#x27;:&#x27;) + 1); if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123; // a file pattern // 找匹配文件 return findPathMatchingResources(locationPattern); &#125; else &#123; // a single resource with the given name return new Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334protected Resource[] findPathMatchingResources(String locationPattern) throws IOException &#123; // 文件夹最后一个目录 /static/*.xml 则rootDirPath=/static/ classpath*:*.xml rootDirPath=classpath*: String rootDirPath = determineRootDir(locationPattern); // 文件匹配，例如：*.xml String subPattern = locationPattern.substring(rootDirPath.length()); // 给定路径下的文件夹作为单个resource Resource[] rootDirResources = getResources(rootDirPath); Set&lt;Resource&gt; result = new LinkedHashSet&lt;&gt;(16); for (Resource rootDirResource : rootDirResources) &#123; rootDirResource = resolveRootDirResource(rootDirResource); // 当前文件夹在系统下的绝对路径 URL rootDirUrl = rootDirResource.getURL(); if (equinoxResolveMethod != null &amp;&amp; rootDirUrl.getProtocol().startsWith(&quot;bundle&quot;)) &#123; // 判断协议是否是bundle URL resolvedUrl = (URL) ReflectionUtils.invokeMethod(equinoxResolveMethod, null, rootDirUrl); if (resolvedUrl != null) &#123; rootDirUrl = resolvedUrl; &#125; rootDirResource = new UrlResource(rootDirUrl); &#125; if (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) &#123; // 判断协议是否是vfs result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirUrl, subPattern, getPathMatcher())); &#125; else if (ResourceUtils.isJarURL(rootDirUrl) || isJarResource(rootDirResource)) &#123; // 判断协议是否是jar result.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirUrl, subPattern)); &#125; else &#123; result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern)); &#125; &#125; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Resolved location pattern [&quot; + locationPattern + &quot;] to resources &quot; + result); &#125; return result.toArray(new Resource[0]);&#125; 只不过在调用getResources(rootDirPath)时，实际调用的是new Resource[] {getResourceLoader().getResource(locationPattern)}，然后使用DefaultResourceLoader#getResource将路径转成Resource。后续逻辑和classpath*:一样，遍历Resource数组，然后从文件夹中取文件，最后将文件转成Resource数组返回。 加载文件源码分析完毕，最后总结一下： Resource抽象了文件的描述，ResourceLoader抽象了文件的加载 DefalutResourceLoader为ResourceLoader的默认实现，其getResource只能加载单一文件，ResourcePatternResovler继承ResourceLoader提供了getResources解析ant风格的路径来加载多个文件 PathMatchingResourcePatternResolver作为ResourcePatternResovler的实现类，提供了加载classpath*和file协议的策略","categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"源码","slug":"源码","permalink":"http://example.com/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"1.Spring源码解析-概述","slug":"1-Spring源码解析-概述","date":"2022-01-05T08:55:04.000Z","updated":"2022-01-05T09:18:03.089Z","comments":true,"path":"2022/01/05/1-Spring源码解析-概述/","link":"","permalink":"http://example.com/2022/01/05/1-Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E6%A6%82%E8%BF%B0/","excerpt":"","text":"一、IOC（Inversion Of Control）在Java应用中的对象，在Spring中称为Bean。Spring通过控制反转（又称：依赖注入）来构建和管理bean的生命周期及依赖关系。 以前Java应用都是自身需要哪些对象，便直接在功能模块中使用new得到，造成对象之间的依赖关系过于复杂。Spring将这些对象通过元数据配置（xml配置，Java注解配置等）来构建和管理对象的依赖关系，将获取对象的方式从应用程序主动创建，改变成直接从Spring容器中获取。将对象的依赖关系解耦。 例如找对象，自己找到符合心意的对象比较困难，于是许多未婚男女都会去婚姻介绍所中登记自己的相关信息和求偶标准，然后委托介绍所来负责给他们找对象。当婚姻介绍所找到符合他们需要的对象时，直接通知他们找到了，然后A和B的依赖关系就达成了。 这里的婚姻介绍所就是Spring的容器。A和B相当于未婚男女，当A需要找B类型的对象B时，直接告诉容器，容器便会从登记册中找到B然后提供给A 12345Container（ &quot;A&quot;, &quot;B&quot;, &quot;C&quot;...） 123456@Componentpublic class A &#123; // 告诉Container需要B，Container则会找到B并初始化，注入到A中 @Autowired private B b;&#125; 二、IOC注入方式在Spring中，IOC的注入分为三种：构造方法注入，Setter方法注入，注解注入。 构造方法注入： 1234567891011public class User &#123; private String name; private Integer age; private Address address; public User(String name, Integer age, Address address) &#123; this.name = name; this.age = age; this.address = address; &#125;&#125; 12345&lt;bean id = &quot;user&quot; class=&quot;com.andrew.study.domain.User&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;Andrew&quot; /&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;24&quot; /&gt; &lt;constructor-arg name=&quot;address&quot; ref=&quot;address&quot; /&gt;&lt;/bean&gt; setter注入： 12345678910111213141516171819202122232425public class User &#123; private String name; private Integer age; private Address address; public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public Integer getAge() &#123; return age; &#125;&#125; 12345&lt;bean id = &quot;user&quot; class=&quot;com.andrew.study.domain.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Andrew&quot; /&gt; &lt;property name=&quot;age&quot; value=&quot;24&quot; /&gt; &lt;property name=&quot;address&quot; value=&quot;address&quot; /&gt;&lt;/bean&gt; 注解注入： 123456789101112@Componentpublic class User &#123; @Value(&quot;Andrew&quot;) private String name; @Value(&quot;24&quot;) private Integer age; @Autowired private Address address;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"源码","slug":"源码","permalink":"http://example.com/tags/%E6%BA%90%E7%A0%81/"}]}],"categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"源码","slug":"源码","permalink":"http://example.com/tags/%E6%BA%90%E7%A0%81/"}]}